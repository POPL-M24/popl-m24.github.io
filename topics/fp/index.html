<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-08-15 Thu 16:56 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Functional Programming with Natural numbers  and Lists</title>
<meta name="author" content="Venkatesh Choppella" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/extra.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/js/readtheorg.js"></script>
<script src="../../themes/math/style/js/math.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="../../themes/math/style/css/math.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<link rel="icon" type="image/png" href="../../themes/popl/style/img/favicon/popl.png" />
<div style="display: none"> \(
% Latex Preamble definitions here (mostly usepackage)
\usepackage%
%[dvipsnames]
{xcolor}
% make sure this is before the loading font packages
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage
%[dvipsnames]
{graphicx}
\usepackage{float}
%\usepackage[numbers]{natbib}
\usepackage[document]{ragged2e}
%
% enumitem doesn't seem to work with beamer
%\usepackage[inline]{enumitem}
\usepackage{wrapfig}
\usepackage{stackrel}
% extensible arrows
\usepackage{extpfeil}
% \usepackage{trfrac}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{automata, positioning, arrows, shapes.geometric}
\usepackage{turnstile}
\usepackage{comment}
%https://tex.stackexchange.com/questions/21334/is-there-a-package-that-has-the-clockwise-gapped-circle-arrow-in-it
% \usepackage{mathbx}
\usepackage{datetime}
\usepackage{datetime2}

%% Also See
%% http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% for general tips
\usepackage{listings}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{amsfonts} %% - also included by amssymb
\usepackage{mathpazo} %% - because the OP uses mathpazo, optional
%\usepackage{tufte-latex}
\usepackage{comment}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{hyperref}
%\usepackage{cleveref}
\)</div>
<div style="display: none"> \(
%% Your math definitions here
% \newcommand{\alphaequiv}{{\underset{\raise 0.7em\alpha}{=}}}
\newcommand{\yields}{\Rightarrow}
\newcommand{\derives}{\overset{*}{\yields}}
\newcommand{\alphaequiv}{=_{\alpha}}
\newcommand{\tto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\transitsto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\xtransitsto}[2]{{\underset{#2}{\xrightarrow{#1}}}}
\newcommand{\xtransitsfrom}[2]{{\underset{#2}{\xleftarrow{#1}}}}
\newcommand{\xto}[2]{{\xtransitsto{#1}{#2}}}
\newcommand{\xfrom}[2]{{\xtransitsfrom{#1}{#2}}}
\newcommand{\xreaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
\newcommand{\reaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
%\newcommand{\reaches}[2]{{\overset{#1}{\underset{#2}{\twoheadrightarrow}}}}
%\newcommand{\goesto}[2]{\transitsto{#1}{#2}}
%\newcommand{\betareducesto}{{\underset{\beta}{\rightarrow}}}
\newcommand{\betareducesto}{\rightarrow_{\beta}}
%\newcommand{\etareducesto}{{\underset{\eta}{\rightarrow}}}
\newcommand{\etareducesto}{\rightarrow_{\eta}}
%\newcommand{\betaetareducesto}{{\underset{\beta\ \eta}{\rightarrow}}}
\newcommand{\betaetareducesto}{\rightarrow_{\beta\eta}}
\newcommand{\preducesto}{\rhd}
\newcommand{\psimplifiesto}{\stackrel{\scriptstyle{*}}{\rhd}}
\newcommand{\lreducesto}{\rightsquigarrow}
\newcommand{\lsimplifiesto}{\stackrel{\scriptstyle{*}}{\lreducesto}}
\newcommand{\rewritesto}{\hookrightarrow}
\newcommand{\goesto}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\xgoesto}[1]{\xrightarrow{#1}}
\newcommand{\reducesto}{\stackrel{}{\rightarrow}}
\newcommand{\simplifiesto}{\stackrel{\scriptstyle{*}}{\rightarrow}}
\newcommand{\connected}[1]{\stackrel{#1}{\leftrightarrow}}
\newcommand{\joins}{\downarrow}
\newcommand{\evaluatesto}{\Longrightarrow}
%\newcommand{\lit}[1]{\hbox{\sf{#1}}}
\newcommand{\lit}[1]{{\sf{#1}}}
\newcommand{\true}{\lit{true}}
\newcommand{\false}{\lit{false}}
\def\Z{\mbox{${\mathbb Z}$}}
\def\N{\mbox{${\mathbb N}$}}
\def\P{\mbox{${\mathbb P}$}}
\def\R{\mbox{${\mathbb R}$}}
\def\T{\mbox{${\mathbb T}$}}
\newcommand{\Rp}{{\mathbb{R}}^+}
\def\Bool{\mbox{${\mathbb B}$}}
\def\Q{\mbox{${\mathbb Q}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sL{\mbox{${\cal L}$}}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\sR{\mbox{${\cal R}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sO{\mbox{${\cal O}$}}
\def\sT{\mbox{${\cal T}$}}
\def\sU{\mbox{${\cal U}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\osum{${{\bigcirc}}\!\!\!\!{\rm s}~$}
\def\pf{\noindent {\bf Proof}~~}
\def\exec{\mathit{exec}}
\def\Act{\mathit{A\!ct}}
\def\Traces{\mathit{Traces}}
\def\Spec{\mathit{Spec}}
\def\uns{\mathit{unless}}
\def\ens{\mathit{ensures}}
\def\lto{\mathit{leads\!\!-\!\!to}}
\def\a{\alpha}
\def\b{\beta}
\def\c{\gamma}
\def\d{\delta}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sI{\mbox{${\cal I}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sR{\mbox{${\cal R}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\ta{\mbox{$\widetilde{a}$}}
\def\tb{\mbox{$\widetilde{b}$}}
\def\tc{\mbox{$\widetilde{c}$}}
\def\tx{\mbox{$\widetilde{x}$}}
\def\ty{\mbox{$\widetilde{y}$}}
\def\tz{\mbox{$\widetilde{z}$}}
\def\tI{\mbox{$\widetilde{I}$}}
\def\norm{\mbox{$\parallel$}}
\def\sL{\mbox{${\cal L}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\to{\rightarrow}
\def\ov{\overline}
\def\gets{\leftarrow}
\def\too{\longrightarrow}
\def\To{\Rightarrow}
%\def\points{\mapsto}
%\def\yields{\mapsto^{*}}
\def\un{\underline}
\def\vep{$\varepsilon$}
\def\ep{$\epsilon$}
\def\tri{$\bigtriangleup$}
\def\Fi{$F^{\infty}$}
\def\Di{\Delta^{\infty}}
\def\ebox\Box
\def\emp{\emptyset}
\def\leadsto{\rightharpoondown^{*}}

\newcommand{\benum}{\begin{enumerate}}
\newcommand{\eenum}{\end{enumerate}}
\newcommand{\bdes}{\begin{description}}
\newcommand{\edes}{\end{description}}
\newcommand{\bt}{\begin{theorem}}
\newcommand{\et}{\end{theorem}}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
% \newcommand{\bp}{\begin{prop}}
% \newcommand{\ep}{\end{prop}}
\newcommand{\bd}{\begin{defn}}
\newcommand{\ed}{\end{defn}}
\newcommand{\brem}{\begin{remark}}
\newcommand{\erem}{\end{remark}}
\newcommand{\bxr}{\begin{exercise}}
\newcommand{\exr}{\end{exercise}}
\newcommand{\bxm}{\begin{example}}
\newcommand{\exm}{\end{example}}
\newcommand{\beqa}{\begin{eqnarray*}}
\newcommand{\eeqa}{\end{eqnarray*}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bcent}{\begin{center}}
\newcommand{\ecent}{\end{center}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\bcor}{\begin{corollary}}
\newcommand{\ecor}{\end{corollary}}
\newcommand{\bds}{\begin{defns}}
\newcommand{\eds}{\end{defns}}
\newcommand{\brems}{\begin{remarks}}
\newcommand{\erems}{\end{remarks}}
\newcommand{\bxrs}{\begin{exercises}}
\newcommand{\exrs}{\end{exercises}}
\newcommand{\bxms}{\begin{examples}}
\newcommand{\exms}{\end{examples}}
\newcommand{\bfig}{\begin{figure}}
\newcommand{\efig}{\end{figure}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\pair}[1]{\langle #1\rangle}
\newcommand{\tuple}[1]{\langle #1\rangle}
\newcommand{\size}[1]{| #1 |}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersection}{\cap}
\newcommand{\Intersection}{\bigcap}
\newcommand{\B}{\textbf{B}}
%\newcommand{\be}[2]{\begin{equation} \label{#1} \tag{#2} \end{equation}}
\newcommand{\abs}[1]{{\lvert}#1{\rvert}}
\newcommand{\id}[1]{\mathit{#1}}
\newcommand{\pfun}{\rightharpoonup}
%\newcommand{\ra}[1]{\kern-1.5ex\xrightarrow{\ \ #1\ \ }\phantom{}\kern-1.5ex}
%\newcommand{\ras}[1]{\kern-1.5ex\xrightarrow{\ \ \smash{#1}\ \ }\phantom{}\kern-1.5ex}
\newcommand{\da}[1]{\bigg\downarrow\raise.5ex\rlap{\scriptstyle#1}}
\newcommand{\ua}[1]{\bigg\uparrow\raise.5ex\rlap{\scriptstyle#1}}
% \newcommand{\lift}[1]{#1_{\bot}}
\newcommand{\signal}[1]{\tilde{#1}}
\newcommand{\ida}{\stackrel{{\sf def}}{=}}
\newcommand{\eqn}{\doteq}
\newcommand{\deduce}[1]{\sststile{#1}{}}

%% These don't sit very well with MathJax
%% so we don't plan to use theorem like environments
%% in org documents.
%% instead we plan to use headings with
%%  1. property drawers with a CLASS property identifying
%%  the environment
%%  2. A tag with the same name as the CLASS property
%%  In LaTeX export, these turn into (sub)sections.


%% See http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% \newtheorem{prop}[thm]{Proposition}
%% \theoremstyle{plain}%default
%% \newtheorem{theorem}{Theorem}[section]
%% \newtheorem{lemma}{Lemma}[section]
%% \newtheorem{corollary}{Corollary}[section]
%% \newtheorem{definition}{Definition}[section]
%% \newtheorem{remark}{Remark}[section]
%% \newtheorem{example}{Example}[section]
%% \newtheorem{exercise}{Exercise}[section]



\newcommand{\less}[1]{#1_{<}}
\newcommand{\pfn}{\rightharpoonup}
\newcommand{\ffn}{\stackrel{{\sf fin}}{\rightharpoonup}}
\newcommand{\stkout}[1]{\ifmmode\text{\sout{\ensuremath{#1}}}\else\sout{#1}\fi}

% Caution: Not supported by MathJax!
% ----------------------------------
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}


% \usepackage{amsfonts} %% <- also included by amssymb
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}
\usepackage{mathpazo} %% <- because the OP uses mathpazo, optional



\newcommand{\mbf}[1]{\mathbf{#1}}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\rel}{\twoheadrightarrow}
\newcommand{\map}{\rightarrow}

%\newcommand{\fixed}{\boldsymbol{\circlearrowleft}}
\newcommand{\terminal}{\not\xto{}{}}
\newcommand{\fixed}{\bm\circlearrowleft}

\newcommand{\imp}{\rightarrow}
\newcommand{\dimp}{\leftrightarrow}  % double implication
\newcommand{\lequiv}{\Longleftrightarrow} % logical equivalence
\newcommand{\limplies}{\Rightarrow}
\newcommand{\lxor}{\veebar}
\)</div>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Functional Programming with Natural numbers  and Lists</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8fe87f3">1. Introduction</a></li>
<li><a href="#org3614235">2. Function Composition</a></li>
<li><a href="#orgf13d2fe">3. Sequential Application of Functions</a></li>
<li><a href="#org79d966e">4. Identity Function</a></li>
<li><a href="#org3b6fc7b">5. Variable arity composition and sequentialisation:  <code>comp</code> and <code>seq</code></a></li>
<li><a href="#orgf624361">6. Reduce</a></li>
<li><a href="#orge6ed897">7. Linear Reduction</a></li>
<li><a href="#orga63b85e">8. List Reduction as a Special Case of Linear Reduction</a></li>
<li><a href="#org68e1d52">9. Iteration as a Special Case of Linear Reduction</a></li>
<li><a href="#org9887d52">10. Higher Order Reduction</a></li>
<li><a href="#org830d98c">11. Curried version of basic functions</a></li>
<li><a href="#orgf288717">12. Non-determinism</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8fe87f3" class="outline-2">
<h2 id="org8fe87f3"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In this section, we look at functional programming, or
programming with functions as values on their own right.  A
<i>functional</i> is a function that takes or returns functions.
In mathematics, functionals are very common, although they
are better known as <i>operators</i>.  Examples: the compose
operator, denoted \(f\circ g\), which takes two functions \(f\)
and \(g\) and returns their composition \(\lambda x.\ f(g(x))\).
Another example is the iterate operator denoted by
superscripts: \(f^{i}\) is the function obtained by iterating
\(f\) \(i\) times.
</p>

<p>
Functional Programming is a style of programming where one
can write functions that take or return functions.
Racket/Scheme is eminently suited for functional
programming.
</p>

<p>
Functional Programming is useful because it lets one write
programs (functions) that generate other functions.  This
allows one to write very general programs at a high level of
abstraction and then specialise these high level programs to
generate more specific programs.  Several examples of this
type of abstraction followed by specialisation are presented
in this section.
</p>
</div>
</div>

<div id="outline-container-org3614235" class="outline-2">
<h2 id="org3614235"><span class="section-number-2">2.</span> Function Composition</h2>
<div class="outline-text-2" id="text-2">
<p>
Given two functions \(f:A\rightarrow B\) and \(g:B\rightarrow
C\), the composition of \(g\) with \(f\), written \(g\circ f:\) is
the function from \(A\) to \(C\) defined as \((g\circ f)(x)=
g(f(x))\). 
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define comp2
  (lambda (g f)
    (lambda (x)
      (g (f x)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-scheme">(check-equal? ((comp2 (lambda (x) (* x 2))
                     (lambda (x) (+ 1 x)))
               3)
              8
              "comp-1-test")
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">(check-equal? ((comp2 even? first) '(8 3 4))
              #t
              "comp-2-test")
</pre>
</div>

<p>
Notice the <i>generation</i> of the new composite function by
<code>comp2</code>.  Thus <code>comp2</code> denotes a <i>higher-order
function</i> that takes two functions as arguments and returns
a function as the result.
</p>

<p>
Thus we can write the conversion from Centigrade to
Fahrenheit as a composition of two smaller functions:
</p>

<div class="org-src-container">
<pre class="src src-scheme">
(define add32
  (lambda (x) (+ 32 x)))

(define mul-with-9/5
   (lambda (x) (* 9/5 x)))

(define c-&gt;f1  ;; using comp2
  (comp2 add32 mul-with-9/5))

(check-equal?  (c-&gt;f1 0) 32 "c-&gt;f1-1")
(check-equal?  (c-&gt;f1 100) 212 "c-&gt;f1-2")
(check-equal?  (c-&gt;f1 -40) -40 "c-&gt;f1-3")
</pre>
</div>

<p>
Note that although <code>c-&gt;f1</code> is a function from (a number
denoting) temperature to temperature, there is no reference
to the temperature a formal parameter in the definition of
<code>c-&gt;f1</code>.  It has been abstracted away.  Abstractions such as
these result in programs that are compact, but which,
without some practice, also seem inscrutable.  The advantage
of the compactness is, however, compelling.  
</p>
</div>
</div>

<div id="outline-container-orgf13d2fe" class="outline-2">
<h2 id="orgf13d2fe"><span class="section-number-2">3.</span> Sequential Application of Functions</h2>
<div class="outline-text-2" id="text-3">
<p>
Another way to think about composition (and this is less
confusing for some) is the operator $;$ often used in
programming languages like C to express sequential
operation.
</p>

<p>
\(f;g\) takes an \(x:A\) and returns \(g(f(x))\).  Note that \(f;g
= g\circ f\), but the notation \(f;g\) aligns better with the
left to right reading: apply \(f\); then apply \(g\).
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define seq2
  (lambda (f g)
    (comp2 g f)))

(define c-&gt;f2 ;; using seq2
  (seq2 mul-with-9/5 add32))

(check-equal?  (c-&gt;f2 0) 32 "c-&gt;f2-1")
(check-equal?  (c-&gt;f2 100) 212 "c-&gt;f2-2")
(check-equal?  (c-&gt;f2 -40) -40 "c-&gt;f2-3")
</pre>
</div>
</div>
</div>

<div id="outline-container-org79d966e" class="outline-2">
<h2 id="org79d966e"><span class="section-number-2">4.</span> Identity Function</h2>
<div class="outline-text-2" id="text-4">
<p>
The identity function \(\mathit{Id}\) is useful function to
have around.  Notice that \(f;\mathit{Id} = \mathit{Id};f =
f\) for any function \(f\).
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define id
  (lambda (x) x))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b6fc7b" class="outline-2">
<h2 id="org3b6fc7b"><span class="section-number-2">5.</span> Variable arity composition and sequentialisation:  <code>comp</code> and <code>seq</code></h2>
<div class="outline-text-2" id="text-5">
<p>
The composition and sequentilisation  operators may be
generalized to arbitrary arity:
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; comp: [A_{n-1} -&gt; A_n, A_{n-2} -&gt; A_{n-1} ... A_{0} -&gt; A_{1}] -&gt; A_0 -&gt; A_n
(define comp
  (lambda fs
    (cond
      [(null? fs) id]
      [else (comp2 (first fs) (apply comp (rest fs)))])))


(define sqr
  (lambda (x) (* x x)))

(check-equal? ((comp) 5) 5 "comp-1")
(check-equal? ((comp add1) 5) 6 "comp-2")
(check-equal? ((comp add1 sqr) 5) 26 "comp-3")
(check-equal? ((comp add1 sqr mul-with-9/5) 5) 82 "comp-4")

;;; seq: [A_0 -&gt; A_1, A_1 -&gt; A_2 ... A_{n-1} -&gt; A_n] -&gt; A_0 -&gt; A_n
(define seq
  (lambda fs
    (cond
      [(null? fs) id]
      [else (seq2 (first fs) (apply seq (rest fs)))])))

(check-equal? ((seq) 5) 5 "seq-1")
(check-equal? ((seq add1) 5) 6 "seq-2")
(check-equal? ((seq add1 sqr) 5) 36 "seq-3")
(check-equal? ((seq add1 sqr mul-with-9/5) 4) 45 "seq-4")
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf624361" class="outline-2">
<h2 id="orgf624361"><span class="section-number-2">6.</span> Reduce</h2>
<div class="outline-text-2" id="text-6">
<p>
Recall the notion of a deterministic, non-blocking state
machine.  
</p>

<p>
\[ S = \pair{X, U, Y, f:X,U\rightarrow X, h:X\rightarrow Y} \]
</p>

<p>
Deterministic and non-blocking means that there is exactly
one next state for each state \(x\) and each input \(u\) and
that state is \(f(x,u)\). 
</p>

<p>
Given a state \(x\in X\) and a sequence \(\overline{u}\) of
inputs, we are interested in knowing what is the output of
the machine after it consumes the input \(\overline{u}\).
Such a function is easy to write in functional programming.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define list-reduce1
  (lambda (f h) 
    (lambda (x us)
      (letrec ([loop 
                (lambda (us a)
                  (cond
                   [(null? us) (h a)]
                   [else (loop (rest us) (f a (first us)))]))])
        (loop us x)))))

;;; computes the length of a list
(define list-length1
  (list-reduce1 (lambda (a u)  (add1 a)) id))

(check-equal? (list-length1 0 '(a b c))
              3 "reduce1-1")

;;; reverses a list
(define list-reverse1
  (list-reduce1 (lambda (a u) (cons u a))  id))

(check-equal? (list-reverse1 '() '(a b c))
              '(c b a) "reduce1-2")

;;; sums the numbers in a list of numbers
(define list-sum1
  (list-reduce1 + id))

(check-equal? (list-sum1 0 '(1 5 2)) 8 "reduce1-3")

</pre>
</div>

<p>
The function <code>list-reduce1</code> takes the functions \(f\) and \(h\)
above and returns a function that takes a state \(x\) and a
sequence of inputs \(us\) and returns the output of the state
reached after consuming the entire input <code>us</code>.
</p>
</div>
</div>

<div id="outline-container-orge6ed897" class="outline-2">
<h2 id="orge6ed897"><span class="section-number-2">7.</span> Linear Reduction</h2>
<div class="outline-text-2" id="text-7">
<p>
By abstracting the sequencing operators of the input
sequence, we get the following <i>generalized</i> reduce operator
that works on finite linear structures that includes lists
and also natural numbers. 
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; [first: (seq U) -&gt; U, rest: (seq U) -&gt; (seq U), base?: (seq U) -&gt; boolean?] 
;;;   -&gt; [init: X, f: [X,U]-&gt;X, h: X-&gt;Y] -&gt; (seq U) -&gt; Y
(define linear-reduce
  (lambda (first rest base?)
    (lambda (f h) 
      (lambda:  (x us)
        (letrec ([loop (lambda (us x)
                         (cond
                           [(base? us) (h x)]
                           [else (loop (rest us) (f x (first us)))]))])
          (loop us x))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga63b85e" class="outline-2">
<h2 id="orga63b85e"><span class="section-number-2">8.</span> List Reduction as a Special Case of Linear Reduction</h2>
<div class="outline-text-2" id="text-8">
<p>
From this we may easily define reduction on lists as
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define list-reduce
  (linear-reduce first rest null?))

;;; computes the length of a list
(define list-length
  (: (list-reduce (lambda (a u)  (add1 a)) id) 0))

(check-equal? (list-length '(a b c))
              3 "list-length-1")

;;; sums the numbers in a list of numbers
(define list-sum
  (: (list-reduce + identity) 0))

(check-equal? (list-sum '(1 5 2)) 8 "list-sum-1")


;;; reverses a list
(define list-reverse
  (: (list-reduce (lambda (a u) (cons u a))  id) '()))

(check-equal? (list-reverse '(a b c))
              '(c b a) "list-reverse-1")

;;; list-map: A-&gt;B -&gt; list[A] -&gt; list[B]
(define list-map
  (lambda (g)
    (: (list-reduce (lambda (ls u) (cons (g u) ls)) reverse) '())))

(check-equal? (: list-map add1 '(2 7 3)) '(3 8 4) "list-map-1")
</pre>
</div>
</div>
</div>

<div id="outline-container-org68e1d52" class="outline-2">
<h2 id="org68e1d52"><span class="section-number-2">9.</span> Iteration as a Special Case of Linear Reduction</h2>
<div class="outline-text-2" id="text-9">
<p>
Natural numbers are also linear structures.  A natural
number \(n\) is isomorphic to a list of n objects.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nat-reduce
  (linear-reduce identity sub1 zero?))

;;; nat? -&gt; nat?
(define nat-sum
  (: (nat-reduce + identity)
     0))

(check-equal?  (nat-sum 0) 0 "nat-sum-1")
(check-equal?  (nat-sum 4) 10 "nat-sum-2")

;;; nat? -&gt; nat?
(define nat-prod ;; factorial
  (: (nat-reduce * identity)
     1))


(check-equal?  (nat-prod 0) 1 "nat-prod-1")
(check-equal?  (nat-prod 4) 24 "nat-prod-2")

;;; f:A-&gt;A -&gt; n:nat? -&gt; A-&gt;A
(define nat-iterate
  (lambda (f)
    (: (nat-reduce (lambda (g n) (comp2 f g)) identity)
       identity)))

(check-equal?  (: nat-iterate add1 4 3) 7 "nat-iterate-1")
(check-equal?  (: nat-iterate add1 0 3) 3 "nat-iterate-2")
</pre>
</div>
</div>
</div>

<div id="outline-container-org9887d52" class="outline-2">
<h2 id="org9887d52"><span class="section-number-2">10.</span> Higher Order Reduction</h2>
<div class="outline-text-2" id="text-10">
<p>
Can the above programs be made more compact?  The answer is
yes!  In the programs that follow, we will aggressively use
currying, and will define functions in a curried way
wherever possible and useful.
</p>

<p>
We curry the arguments <code>f</code> and <code>h</code>.  Further, we also switch
the arguments of <code>f</code>, so the signature of \(f\) is now
\(f:U\rightarrow X\rightarrow X\).  We also switch the order
of arguments to <code>loop</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; [first: (seq U) -&gt; U, rest: (seq U) -&gt; (seq U), base?: (seq U) -&gt; boolean?] 
;;;   -&gt; [f: U-&gt;X-&gt;X, h: X-&gt;Y] -&gt; (seq U) -&gt; X -&gt; Y
(define linear-reduce-t1:  ;; take 1
  (lambda (first rest base?)
    (lambda: (f h) 
      (letrec ([loop (lambda: (us x)
                       (cond
                         [(base? us) (h x)]
                         [else (: loop (rest us)
                                  (: f (first us) x))]))])
               loop))))
</pre>
</div>

<p>
Notice that the clause in the <code>else</code> part of <code>loop</code>'s
definition may be written using <code>seq</code>, and as a result, the
<code>x</code> may be factored out of the definition: 
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; [first: (seq U) -&gt; U, rest: (seq U) -&gt; (seq U), base?: (seq U) -&gt; boolean?] 
;;;   -&gt; [f: U-&gt;X-&gt;X, h: X-&gt;Y] -&gt; (seq U) -&gt; X -&gt; Y
(define linear-reduce: ;;; take2
  (lambda (first rest base?)
    (lambda: (f h) 
      (letrec ([loop (lambda (us)
                       (cond
                         [(base? us) h]
                         [else (seq (: (seq first f) us)
                                    (: (seq rest loop) us))]))])
        loop))))
</pre>
</div>

<p>
<b>Exercise</b>: derive the equivalence of <code>linear-reduce</code> and
<code>linear-reduce-t1</code> using the rules of eta reduction i.e.,
<code>(lambda (x) (e x)) = e</code> (provided <code>x</code> is not a free
variable in <code>e</code>) and the definition of <code>seq</code>.
</p>
</div>
</div>

<div id="outline-container-org830d98c" class="outline-2">
<h2 id="org830d98c"><span class="section-number-2">11.</span> Curried version of basic functions</h2>
<div class="outline-text-2" id="text-11">
<p>
First, we defined curried versions of binary functions <code>+</code>
and <code>cons</code>:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define +:
  (lambda: (x y) (+ x y)))

(define cons:
  (lambda: (x ls) (cons x ls)))
</pre>
</div>

<p>
The curried  <code>list-reduce:</code> and various functions generated
from it may now be defined as follows
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define list-reduce:
  (linear-reduce: first rest null?))

;;; computes the length of a list
(define list-length:
  (lambda (ls)
    (: list-reduce: (lambda (u) add1) id ls 0)))

(check-equal? (list-length: '(a b c))
              3 "list-length:-1")

;;; sums the numbers in a list of numbers
(define list-sum:
  (lambda (ls)
    (: list-reduce: +: id ls 0)))

(check-equal? (list-sum: '(1 5 2)) 8 "list-sum:-1")


;;; reverses a list
(define list-reverse:
  (lambda (ls) 
    (: list-reduce: cons: id ls '())))

(check-equal? (list-reverse: '(a b c))
              '(c b a) "list-reverse-1")


(define list-map:
  (lambda: (g ls)
    (: list-reduce: (seq g cons:) reverse ls '())))

(check-equal? (: list-map: add1 '(2 7 3)) '(3 8 4) "list-map:-1")
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf288717" class="outline-2">
<h2 id="orgf288717"><span class="section-number-2">12.</span> Non-determinism</h2>
<div class="outline-text-2" id="text-12">
<p>
Consider a non-deterministic state machine 
</p>

<p>
\[S = \pair{X, U, f:U\rightarrow X\rightarrow 2^{X}, X, h:X\rightarrow X}\]
</p>

<p>
The transition relation in \(S\) is specified by the function
\(f:U\rightarrow X\rightarrow 2^{X}\) and output function \(h\)
is assumed identity.  The corresponding reduce function
<code>nd-reduce:</code> takes a list of inputs <code>us</code> and a set of states
<code>xs</code> and returns the set of states reachable from <code>xs</code> via
<code>us</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define set-mapf
  (lambda (f sets)
    (set-map sets f)))

;;; nd:reduce:-t1 : [f: U-&gt;X-&gt;set[X]] -&gt; list[U] -&gt; set[X] -&gt; set[X]
(define nd-reduce:-t1
  (lambda (f)
    (: list-reduce:
       (lambda: (u xs)
         (apply set-union (set-mapf (f u) xs)))
       id)))
</pre>
</div>

<p>
The next few programs illustrate an exercise in code
refactoring.  Our goal is to write a version of <code>nd-reduce</code>
that abstracts away the parameters <code>xs</code> and <code>u</code> (in that
order).  
</p>

<p>
We start by currying <code>set-mapf</code> and <code>apply</code>:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define set-mapf:
  (lambda: (f sets)
    (set-map sets f)))

(define apply:
  (lambda: (fn args)
    (apply fn args)))

(define nd-reduce:-t2  ;; take 2
  (lambda (f)
    (: list-reduce:
       (lambda: (u xs)
         (: apply: set-union (: set-mapf: (f u) xs)))
       id)))
</pre>
</div>

<p>
Expanding the definition of <code>:</code>, we have
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t3
  (lambda (f)
    (: list-reduce:
       (lambda: (u xs)
         ((apply: set-union) ((set-mapf: (f u)) xs)))
       id)))
</pre>
</div>


<p>
Expanding the definition of <code>lambda:</code>, we have
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t4
  (lambda (f)
    (: list-reduce:
       (lambda (u)
         (lambda (xs)
           ((apply: set-union) ((set-mapf: (f u)) xs))))
       id)))
</pre>
</div>

<p>
Introducing <code>comp</code>, we get
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t5
  (lambda (f)
    (: list-reduce:
       (lambda (u)
         (lambda (xs)
           ((comp (apply: set-union) ((comp set-mapf: f) u)) xs)))
       id)))
</pre>
</div>

<p>
Inverse eta reduction abstracts the <code>xs</code> parameter away:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t6
  (lambda (f)
    (: list-reduce:
       (lambda (u)
         (comp (apply: set-union) ((comp set-mapf: f) u)))
       id)))
</pre>
</div>

<p>
By currying <code>comp</code>, we get
</p>
<div class="org-src-container">
<pre class="src src-scheme">(define comp2:
  (lambda: (f g)
    (comp2 f g)))

(define nd-reduce:-t7
  (lambda (f)
    (: list-reduce:
       (lambda (u)
         ((comp2: (apply: set-union)) ((comp set-mapf: f) u)))
       id)))
</pre>
</div>

<p>
This allows us to abstract away the <code>u</code>
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t8
  (lambda (f)
    (: list-reduce:
       (comp (comp2: (apply: set-union)) (comp set-mapf: f))
       id)))
</pre>
</div>

<p>
Exploiting the associativity of <code>comp</code>, i.e., <code>(comp A (comp
B C))</code> to <code>(comp A B C)</code> we get
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce:-t9
  (lambda (f)
    (: list-reduce:
       (comp (comp2: (apply: set-union)) set-mapf: f)
       id)))
</pre>
</div>

<p>
The code below tests <code>nd-reduce:</code> with a non-deterministic
state machine:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(define nd-reduce: nd-reduce:-t9)
(define nd-reduce-f:
  (let ([f (lambda: (u x)
              (case u
                [(0) (case x
                     [(q0) (set 'q0 'q1)]
                     [(q1) (set 'q1 'q2)]
                     [(q2) (set 'q0)])]
                [else (error 'nd-reduce: "invalid arg ~a" u)]))])
      (nd-reduce: f)))

(check-equal? (: nd-reduce-f: '(0) (set 'q0)) (set 'q0 'q1) "nd-reduce-f:-1")
(check-equal? (: nd-reduce-f: '(0 0) (set 'q0)) (set 'q0 'q1 'q2) "nd-reduce-f:-2")
(check-equal? (: nd-reduce-f: '(0 0 0) (set 'q0)) (set 'q0 'q1 'q2) "nd-reduce-f:-3")
(check-equal? (: nd-reduce-f: '(0) (set 'q0 'q2)) (set 'q0 'q1) "nd-reduce-f:-4")
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Venkatesh Choppella</p>
<p class="date">Created: 2024-08-15 Thu 16:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
