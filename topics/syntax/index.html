<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-08-15 Thu 16:56 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Abstract Syntax Trees and (Un)parsing</title>
<meta name="author" content="Venkatesh Choppella" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script src="../../themes/math/style/js/math.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="../../themes/math/style/css/math.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/extra.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/js/readtheorg.js"></script>
<div style="display: none"> \(
% Latex Preamble definitions here (mostly usepackage)
\usepackage%
%[dvipsnames]
{xcolor}
% make sure this is before the loading font packages
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage
%[dvipsnames]
{graphicx}
\usepackage{float}
%\usepackage[numbers]{natbib}
\usepackage[document]{ragged2e}
%
% enumitem doesn't seem to work with beamer
%\usepackage[inline]{enumitem}
\usepackage{wrapfig}
\usepackage{stackrel}
% extensible arrows
\usepackage{extpfeil}
% \usepackage{trfrac}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{automata, positioning, arrows, shapes.geometric}
\usepackage{turnstile}
\usepackage{comment}
%https://tex.stackexchange.com/questions/21334/is-there-a-package-that-has-the-clockwise-gapped-circle-arrow-in-it
% \usepackage{mathbx}
\usepackage{datetime}
\usepackage{datetime2}

%% Also See
%% http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% for general tips
\usepackage{listings}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{amsfonts} %% - also included by amssymb
\usepackage{mathpazo} %% - because the OP uses mathpazo, optional
%\usepackage{tufte-latex}
\usepackage{comment}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{hyperref}
%\usepackage{cleveref}
\)</div>
<div style="display: none"> \(
%% Your math definitions here
% \newcommand{\alphaequiv}{{\underset{\raise 0.7em\alpha}{=}}}
\newcommand{\yields}{\Rightarrow}
\newcommand{\derives}{\overset{*}{\yields}}
\newcommand{\alphaequiv}{=_{\alpha}}
\newcommand{\tto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\transitsto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\xtransitsto}[2]{{\underset{#2}{\xrightarrow{#1}}}}
\newcommand{\xtransitsfrom}[2]{{\underset{#2}{\xleftarrow{#1}}}}
\newcommand{\xto}[2]{{\xtransitsto{#1}{#2}}}
\newcommand{\xfrom}[2]{{\xtransitsfrom{#1}{#2}}}
\newcommand{\xreaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
\newcommand{\reaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
%\newcommand{\reaches}[2]{{\overset{#1}{\underset{#2}{\twoheadrightarrow}}}}
%\newcommand{\goesto}[2]{\transitsto{#1}{#2}}
%\newcommand{\betareducesto}{{\underset{\beta}{\rightarrow}}}
\newcommand{\betareducesto}{\rightarrow_{\beta}}
%\newcommand{\etareducesto}{{\underset{\eta}{\rightarrow}}}
\newcommand{\etareducesto}{\rightarrow_{\eta}}
%\newcommand{\betaetareducesto}{{\underset{\beta\ \eta}{\rightarrow}}}
\newcommand{\betaetareducesto}{\rightarrow_{\beta\eta}}
\newcommand{\preducesto}{\rhd}
\newcommand{\psimplifiesto}{\stackrel{\scriptstyle{*}}{\rhd}}
\newcommand{\lreducesto}{\rightsquigarrow}
\newcommand{\lsimplifiesto}{\stackrel{\scriptstyle{*}}{\lreducesto}}
\newcommand{\rewritesto}{\hookrightarrow}
\newcommand{\goesto}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\xgoesto}[1]{\xrightarrow{#1}}
\newcommand{\reducesto}{\stackrel{}{\rightarrow}}
\newcommand{\simplifiesto}{\stackrel{\scriptstyle{*}}{\rightarrow}}
\newcommand{\connected}[1]{\stackrel{#1}{\leftrightarrow}}
\newcommand{\joins}{\downarrow}
\newcommand{\evaluatesto}{\Longrightarrow}
%\newcommand{\lit}[1]{\hbox{\sf{#1}}}
\newcommand{\lit}[1]{{\sf{#1}}}
\newcommand{\true}{\lit{true}}
\newcommand{\false}{\lit{false}}
\def\Z{\mbox{${\mathbb Z}$}}
\def\N{\mbox{${\mathbb N}$}}
\def\P{\mbox{${\mathbb P}$}}
\def\R{\mbox{${\mathbb R}$}}
\def\T{\mbox{${\mathbb T}$}}
\newcommand{\Rp}{{\mathbb{R}}^+}
\def\Bool{\mbox{${\mathbb B}$}}
\def\Q{\mbox{${\mathbb Q}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sL{\mbox{${\cal L}$}}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\sR{\mbox{${\cal R}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sO{\mbox{${\cal O}$}}
\def\sT{\mbox{${\cal T}$}}
\def\sU{\mbox{${\cal U}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\osum{${{\bigcirc}}\!\!\!\!{\rm s}~$}
\def\pf{\noindent {\bf Proof}~~}
\def\exec{\mathit{exec}}
\def\Act{\mathit{A\!ct}}
\def\Traces{\mathit{Traces}}
\def\Spec{\mathit{Spec}}
\def\uns{\mathit{unless}}
\def\ens{\mathit{ensures}}
\def\lto{\mathit{leads\!\!-\!\!to}}
\def\a{\alpha}
\def\b{\beta}
\def\c{\gamma}
\def\d{\delta}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sI{\mbox{${\cal I}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sR{\mbox{${\cal R}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\ta{\mbox{$\widetilde{a}$}}
\def\tb{\mbox{$\widetilde{b}$}}
\def\tc{\mbox{$\widetilde{c}$}}
\def\tx{\mbox{$\widetilde{x}$}}
\def\ty{\mbox{$\widetilde{y}$}}
\def\tz{\mbox{$\widetilde{z}$}}
\def\tI{\mbox{$\widetilde{I}$}}
\def\norm{\mbox{$\parallel$}}
\def\sL{\mbox{${\cal L}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\to{\rightarrow}
\def\ov{\overline}
\def\gets{\leftarrow}
\def\too{\longrightarrow}
\def\To{\Rightarrow}
%\def\points{\mapsto}
%\def\yields{\mapsto^{*}}
\def\un{\underline}
\def\vep{$\varepsilon$}
\def\ep{$\epsilon$}
\def\tri{$\bigtriangleup$}
\def\Fi{$F^{\infty}$}
\def\Di{\Delta^{\infty}}
\def\ebox\Box
\def\emp{\emptyset}
\def\leadsto{\rightharpoondown^{*}}

\newcommand{\benum}{\begin{enumerate}}
\newcommand{\eenum}{\end{enumerate}}
\newcommand{\bdes}{\begin{description}}
\newcommand{\edes}{\end{description}}
\newcommand{\bt}{\begin{theorem}}
\newcommand{\et}{\end{theorem}}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
% \newcommand{\bp}{\begin{prop}}
% \newcommand{\ep}{\end{prop}}
\newcommand{\bd}{\begin{defn}}
\newcommand{\ed}{\end{defn}}
\newcommand{\brem}{\begin{remark}}
\newcommand{\erem}{\end{remark}}
\newcommand{\bxr}{\begin{exercise}}
\newcommand{\exr}{\end{exercise}}
\newcommand{\bxm}{\begin{example}}
\newcommand{\exm}{\end{example}}
\newcommand{\beqa}{\begin{eqnarray*}}
\newcommand{\eeqa}{\end{eqnarray*}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bcent}{\begin{center}}
\newcommand{\ecent}{\end{center}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\bcor}{\begin{corollary}}
\newcommand{\ecor}{\end{corollary}}
\newcommand{\bds}{\begin{defns}}
\newcommand{\eds}{\end{defns}}
\newcommand{\brems}{\begin{remarks}}
\newcommand{\erems}{\end{remarks}}
\newcommand{\bxrs}{\begin{exercises}}
\newcommand{\exrs}{\end{exercises}}
\newcommand{\bxms}{\begin{examples}}
\newcommand{\exms}{\end{examples}}
\newcommand{\bfig}{\begin{figure}}
\newcommand{\efig}{\end{figure}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\pair}[1]{\langle #1\rangle}
\newcommand{\tuple}[1]{\langle #1\rangle}
\newcommand{\size}[1]{| #1 |}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersection}{\cap}
\newcommand{\Intersection}{\bigcap}
\newcommand{\B}{\textbf{B}}
%\newcommand{\be}[2]{\begin{equation} \label{#1} \tag{#2} \end{equation}}
\newcommand{\abs}[1]{{\lvert}#1{\rvert}}
\newcommand{\id}[1]{\mathit{#1}}
\newcommand{\pfun}{\rightharpoonup}
%\newcommand{\ra}[1]{\kern-1.5ex\xrightarrow{\ \ #1\ \ }\phantom{}\kern-1.5ex}
%\newcommand{\ras}[1]{\kern-1.5ex\xrightarrow{\ \ \smash{#1}\ \ }\phantom{}\kern-1.5ex}
\newcommand{\da}[1]{\bigg\downarrow\raise.5ex\rlap{\scriptstyle#1}}
\newcommand{\ua}[1]{\bigg\uparrow\raise.5ex\rlap{\scriptstyle#1}}
% \newcommand{\lift}[1]{#1_{\bot}}
\newcommand{\signal}[1]{\tilde{#1}}
\newcommand{\ida}{\stackrel{{\sf def}}{=}}
\newcommand{\eqn}{\doteq}
\newcommand{\deduce}[1]{\sststile{#1}{}}

%% These don't sit very well with MathJax
%% so we don't plan to use theorem like environments
%% in org documents.
%% instead we plan to use headings with
%%  1. property drawers with a CLASS property identifying
%%  the environment
%%  2. A tag with the same name as the CLASS property
%%  In LaTeX export, these turn into (sub)sections.


%% See http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% \newtheorem{prop}[thm]{Proposition}
%% \theoremstyle{plain}%default
%% \newtheorem{theorem}{Theorem}[section]
%% \newtheorem{lemma}{Lemma}[section]
%% \newtheorem{corollary}{Corollary}[section]
%% \newtheorem{definition}{Definition}[section]
%% \newtheorem{remark}{Remark}[section]
%% \newtheorem{example}{Example}[section]
%% \newtheorem{exercise}{Exercise}[section]



\newcommand{\less}[1]{#1_{<}}
\newcommand{\pfn}{\rightharpoonup}
\newcommand{\ffn}{\stackrel{{\sf fin}}{\rightharpoonup}}
\newcommand{\stkout}[1]{\ifmmode\text{\sout{\ensuremath{#1}}}\else\sout{#1}\fi}

% Caution: Not supported by MathJax!
% ----------------------------------
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}


% \usepackage{amsfonts} %% <- also included by amssymb
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}
\usepackage{mathpazo} %% <- because the OP uses mathpazo, optional



\newcommand{\mbf}[1]{\mathbf{#1}}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\rel}{\twoheadrightarrow}
\newcommand{\map}{\rightarrow}

%\newcommand{\fixed}{\boldsymbol{\circlearrowleft}}
\newcommand{\terminal}{\not\xto{}{}}
\newcommand{\fixed}{\bm\circlearrowleft}

\newcommand{\imp}{\rightarrow}
\newcommand{\dimp}{\leftrightarrow}  % double implication
\newcommand{\lequiv}{\Longleftrightarrow} % logical equivalence
\newcommand{\limplies}{\Rightarrow}
\newcommand{\lxor}{\veebar}
\)</div>
<link rel="icon" type="image/png" href="../../themes/popl/style/img/favicon/popl.png" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'left',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    output: {
      font: 'mathjax-euler',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Abstract Syntax Trees and (Un)parsing</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge435182">1. Introduction</a>
<ul>
<li><a href="#org565d5c2">1.1. How is a program represented?</a></li>
</ul>
</li>
<li><a href="#orgd47db7e">2. ADDITION Language</a></li>
<li><a href="#org72d1c0f">3. Program Representation</a>
<ul>
<li><a href="#org97aa804">3.1. Concrete Syntax</a></li>
<li><a href="#org6c0d52b">3.2. Strings vs Trees</a></li>
<li><a href="#org6aaaaf4">3.3. Abstract Syntax</a></li>
<li><a href="#org10b3069">3.4. Drawing ASTs</a></li>
<li><a href="#orgddf0ccc">3.5. Lisp concrete syntax</a></li>
</ul>
</li>
<li><a href="#orge8c926b">4. More complex languages</a>
<ul>
<li><a href="#org11d0b74">4.1. Practical notational conventions</a></li>
</ul>
</li>
<li><a href="#orgf4a0dfc">5. Syntax and Inference Rules</a>
<ul>
<li><a href="#org7195e86">5.1. Abstract Grammar</a></li>
<li><a href="#orgb80ff9f">5.2. ADDITION syntax as Inference Rules</a></li>
</ul>
</li>
<li><a href="#org06ce0f2">6. AST's in Racket</a>
<ul>
<li><a href="#orga56d746">6.1. Boilerplate</a></li>
<li><a href="#org6c5698f">6.2. <code>define-datatype</code></a></li>
<li><a href="#orgad8f98d">6.3. Constructors and Type predicates auto-defined</a></li>
<li><a href="#org1dadeca">6.4. Testing the AST functions</a></li>
<li><a href="#orgf585d88">6.5. <code>cases</code></a></li>
</ul>
</li>
<li><a href="#orgfea40ca">7. Exercise:  A simple unparser</a>
<ul>
<li><a href="#org6772174">7.1. Choosing a concrete representation</a></li>
<li><a href="#org0c89dbf">7.2. A Datum based prefix syntax</a></li>
<li><a href="#orgc533326">7.3. Unparser and Parser</a></li>
<li><a href="#orgd1c379d">7.4. Unparsing to a datum syntax: Racket implementation</a></li>
<li><a href="#org142f4b6">7.5. Testing <code>unparse</code></a></li>
<li><a href="#orgdcebff7">7.6. An unparser using quasiquote</a></li>
<li><a href="#org4104bdd">7.7. An unparser that generates infix syntax</a></li>
</ul>
</li>
<li><a href="#org5695206">8. Exercise: A datum parser</a>
<ul>
<li><a href="#orgaebd2eb">8.1. A datum vs string parser</a></li>
<li><a href="#orgb71a517">8.2. Does the concrete syntax determine the meaning of programs?</a></li>
<li><a href="#orgc76006b">8.3. A datum parser</a></li>
<li><a href="#org8799b2f">8.4. Testing  <code>parse</code></a></li>
<li><a href="#org874e408">8.5. Datum parser using match</a></li>
<li><a href="#orge126131">8.6. Testing  <code>parse/match</code></a></li>
</ul>
</li>
<li><a href="#org9d088f6">9. Summary</a>
<ul>
<li><a href="#org0e8e0f8">9.1. Key concepts in this lesson</a></li>
<li><a href="#org907ef1e">9.2. Key Racket concepts in this lesson</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orge435182" class="outline-2">
<h2 id="orge435182"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org565d5c2" class="outline-3">
<h3 id="org565d5c2"><span class="section-number-3">1.1.</span> How is a program represented?</h3>
<div class="outline-text-3" id="text-1-1">
<div class="tdl" id="org0f70921">
<dl class="org-dl">
<dt>Welcome</dt><dd>We continue with our study of the principles of
programming languages.</dd>
</dl>


<dl class="org-dl">
<dt>Problem addressed here</dt><dd>We start with the following
question: How are programs represented?</dd>
</dl>


<dl class="org-dl">
<dt>Multiple answers</dt><dd>This question has multiple answers.
In this lesson, we will examine a couple of ways to
answer this question.</dd>
</dl>


<dl class="org-dl">
<dt>Start small</dt><dd>During the course of this semester, we
will examine many small programming
languages.  But it's best to start with
something small, almost, but not quite
trivial.</dd>
</dl>

</div>
</div>
</div>
</div>

<div id="outline-container-orgd47db7e" class="outline-2">
<h2 id="orgd47db7e"><span class="section-number-2">2.</span> ADDITION Language</h2>
<div class="outline-text-2" id="text-2">
<div class="tdl" id="org672d5ae">
<dl class="org-dl">
<dt>Addition language</dt><dd>We will consider the language we
simply call ADDITION.</dd>
</dl>


<dl class="org-dl">
<dt>Addition expressions</dt><dd>Programs are arithmetic
expressions involving natural numbers and a binary
addition operator +.</dd>
</dl>


<dl class="org-dl">
<dt>Ignore Algebra of +</dt><dd>We will ignore the other
algebraic properties (viz., commutativty and
associativity) of + for the moment.</dd>
</dl>

</div>
</div>
</div>

<div id="outline-container-org72d1c0f" class="outline-2">
<h2 id="org72d1c0f"><span class="section-number-2">3.</span> Program Representation</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org97aa804" class="outline-3">
<h3 id="org97aa804"><span class="section-number-3">3.1.</span> Concrete Syntax</h3>
<div class="outline-text-3" id="text-3-1">
<dl class="org-dl">
<dt>Concrete Syntax</dt><dd>the structure of programs as they are
directly seen or entered by the programmer.  Usually the
concrete syntax is a linear sequence of characters
grouped into tokens.</dd>
</dl>


<dl class="org-dl">
<dt>C or Python examples</dt><dd>Here are possible representations of
ADDITION expressions:</dd>
</dl>
<div class="ex" id="org90c3414">
<pre class="example" id="org636ef87">
5
3+4
(3+4)+2
</pre>

</div>
</div>
</div>

<div id="outline-container-org6c0d52b" class="outline-3">
<h3 id="org6c0d52b"><span class="section-number-3">3.2.</span> Strings vs Trees</h3>
<div class="outline-text-3" id="text-3-2">
<div class="tdl" id="org84280f0">
<p>

</p>

<dl class="org-dl">
<dt>Programs as strings</dt><dd>There is an obvious linear structure
of a a program as a string, or sequence of characters.</dd>
</dl>


<dl class="org-dl">
<dt>Programs as Trees</dt><dd>There is a deeper, more abstract
structure embedded within the string, which is a tree.</dd>
</dl>

</div>
</div>
</div>

<div id="outline-container-org6aaaaf4" class="outline-3">
<h3 id="org6aaaaf4"><span class="section-number-3">3.3.</span> Abstract Syntax</h3>
<div class="outline-text-3" id="text-3-3">
<div class="tdl" id="org6432782">
<dl class="org-dl">
<dt>Abstract Syntax Trees</dt><dd>Rather than consider concrete
syntax, which usually involves writing down
expressions linearly, we will assume that expressions
are denoted abstractly as <i>trees</i>.</dd>
</dl>


<dl class="org-dl">
<dt>ASTs</dt><dd>We call these trees Abstract Syntax Trees, or
ASTs for short.</dd>
</dl>

</div>
</div>
</div>
<div id="outline-container-org10b3069" class="outline-3">
<h3 id="org10b3069"><span class="section-number-3">3.4.</span> Drawing ASTs</h3>
<div class="outline-text-3" id="text-3-4">
<div class="tdl" id="org9242c2c">
<dl class="org-dl">
<dt>Leaves are numbers nodes</dt><dd>Notice that the leaves of
these trees are numbers</dd>
</dl>


<dl class="org-dl">
<dt>Internal nodes are +</dt><dd>and each internal vertex is the
operator +.</dd>
</dl>


<pre class="example" id="org06b3a5c">
(3+4)+2:
       +
      / \
     +  2
    / \
   3  4



(3+1)+(2+3):
        *
       / \
      /   +
     +   / \
    / \  2  3 
   3  1
</pre>

</div>
</div>
</div>

<div id="outline-container-orgddf0ccc" class="outline-3">
<h3 id="orgddf0ccc"><span class="section-number-3">3.5.</span> Lisp concrete syntax</h3>
<div class="outline-text-3" id="text-3-5">
<div class="tdl" id="orgd91f19c">
<p>

</p>

<dl class="org-dl">
<dt>Lisp concrete syntax</dt><dd>In the Lisp Family of languages,
it is easier to identify the tree stucture from the
concrete syntax: The matching parentheses enclose
non-leaf subtrees.</dd>
</dl>

<pre class="example" id="orgc63719e">
(+ 3 4)

(+ (+ 3 4)
   2)

(+ (+ 3 1)
   (+ 2 3)

(+ (+ 3 
      (+ 2
         (+ 4 5)))
   (+ (+ 1 8)
      (+ 2 5)))
</pre>

</div>
</div>
</div>
</div>

<div id="outline-container-orge8c926b" class="outline-2">
<h2 id="orge8c926b"><span class="section-number-2">4.</span> More complex languages</h2>
<div class="outline-text-2" id="text-4">
<p>
For the following code in Python,
</p>
<div class="org-src-container">
<pre class="src src-python">while (i &lt;= x):
    i=g(i);
return i;
</pre>
</div>

<p>
An abstract syntax would look something like this:
</p>
<pre class="example" id="org1aec1b1">
      seq
     /   \
    while return
    / \     \
   /   \     i
  &lt;=    @
 / \   / \
i  x   g  i
</pre>

<p>
Can you guess what the <code>seq</code> and <code>@</code> stands for?
</p>
</div>

<div id="outline-container-org11d0b74" class="outline-3">
<h3 id="org11d0b74"><span class="section-number-3">4.1.</span> Practical notational conventions</h3>
<div class="outline-text-3" id="text-4-1">
<div class="tdl" id="org222e9e6">
<p>

</p>

<dl class="org-dl">
<dt>Drawing trees</dt><dd>Drawing trees is a slightly more
elaborate process</dd>
</dl>


<dl class="org-dl">
<dt>Notation</dt><dd>We will continue to write programs in the
concrete syntax as strings, with the
awareness that these really denote trees.</dd>
</dl>


<dl class="org-dl">
<dt>Example</dt><dd>we write</dd>
</dl>

<div class="ex" id="org18d564a">
<pre class="example" id="orga45587f">
3+2
</pre>

</div>

<dl class="org-dl">
<dt>AST</dt><dd>but switch to the AST representation whenever
necessary.</dd>
</dl>


<div class="ex" id="org065515e">
<pre class="example" id="orgf43d756">
  +
 / \
3   2
</pre>

</div>

</div>
</div>
</div>
</div>

<div id="outline-container-orgf4a0dfc" class="outline-2">
<h2 id="orgf4a0dfc"><span class="section-number-2">5.</span> Syntax and Inference Rules</h2>
<div class="outline-text-2" id="text-5">
<p>
We are now interested in specifying the structure of abstract syntax trees.
</p>
</div>

<div id="outline-container-org7195e86" class="outline-3">
<h3 id="org7195e86"><span class="section-number-3">5.1.</span> Abstract Grammar</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The  abstract grammar specifies trees, not strings.
</p>
<pre class="example" id="orge36b302">
&lt;ast&gt; ::=  &lt;number&gt; | + &lt;ast&gt; &lt;ast&gt; 
</pre>
</div>
</div>


<div id="outline-container-orgb80ff9f" class="outline-3">
<h3 id="orgb80ff9f"><span class="section-number-3">5.2.</span> ADDITION syntax as Inference Rules</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Alternatively, we can use inference rules to specify the syntax
</p>
\begin{align*}
\genfrac{}{}{4}{0}{}{n\ Exp} & n\in \N & \hspace{6em}{NUM}\\ \\ \\
%
\genfrac{}{}{4}{0}{{e_1\ Exp}\hspace{2em}{e_2\ Exp}}{e_1 + e_2\ Exp} & & \hspace{2em}{PLUS}
\end{align*}
</div>
</div>
</div>

<div id="outline-container-org06ce0f2" class="outline-2">
<h2 id="org06ce0f2"><span class="section-number-2">6.</span> AST's in Racket</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orga56d746" class="outline-3">
<h3 id="orga56d746"><span class="section-number-3">6.1.</span> Boilerplate</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-racket">#lang racket
(require eopl)
(require rackunit)
;;; the only-in so that we import only what we need and we don't clash
;;; with bindings defined in the eopl module.
(require (only-in racket/list
                  first
                  second
                  third))
(provide (all-defined-out))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c5698f" class="outline-3">
<h3 id="org6c5698f"><span class="section-number-3">6.2.</span> <code>define-datatype</code></h3>
<div class="outline-text-3" id="text-6-2">
<p>
<code>define-datatype</code> is used to define a variant (or sum)
datatype, i.e., a datatype that has multiple variants.  
</p>

<div class="org-src-container">
<pre class="src src-racket">(define-datatype ast ast?
  [num (n number?)]  ; base case
  [plus (left? ast?) (right? ast?)]) ; inductive case
</pre>
</div>
</div>
</div>

<div id="outline-container-orgad8f98d" class="outline-3">
<h3 id="orgad8f98d"><span class="section-number-3">6.3.</span> Constructors and Type predicates auto-defined</h3>
<div class="outline-text-3" id="text-6-3">
<p>
These constructors  get automatically defined
</p>
<pre class="example" id="org348d210">
;;; num : number? -&gt; ast?
;;; plus : [ast?, ast?] -&gt; ast?
</pre>

<p>
These type predicates get automatically defined
</p>
<pre class="example" id="org27eec8f">
;;; ast?    : any/c -&gt; boolean?
</pre>
</div>
</div>

<div id="outline-container-org1dadeca" class="outline-3">
<h3 id="org1dadeca"><span class="section-number-3">6.4.</span> Testing the AST functions</h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">
<pre class="src src-racket">(check-true (ast? (num 5)))
(check-true (ast? (plus (num 5) (num 3))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf585d88" class="outline-3">
<h3 id="orgf585d88"><span class="section-number-3">6.5.</span> <code>cases</code></h3>
<div class="outline-text-3" id="text-6-5">
<p>
<code>cases</code> can be used to identify the appropriate variant 
</p>
<div class="org-src-container">
<pre class="src src-racket">(cases ast (plus (num 5) (num 4))
  [plus (l r) "it's a plus"]
  [else "it's a number"])
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfea40ca" class="outline-2">
<h2 id="orgfea40ca"><span class="section-number-2">7.</span> Exercise:  A simple unparser</h2>
<div class="outline-text-2" id="text-7">
<p>
We now consider two problems
</p>

<ul class="org-ul">
<li>Choosing a concrete representation of addition expressions.</li>

<li>Writing an <i>unparser</i> to convert AST's to expressions in the
concrete syntax.</li>
</ul>
</div>

<div id="outline-container-org6772174" class="outline-3">
<h3 id="org6772174"><span class="section-number-3">7.1.</span> Choosing a concrete representation</h3>
<div class="outline-text-3" id="text-7-1">
<p>
We will experiment with two choices:
</p>

<ol class="org-ol">
<li>A datum (s-exp) based prefix syntax like Racket's own.</li>

<li>An infix syntax, à la Python or C.</li>
</ol>
</div>
</div>

<div id="outline-container-org0c89dbf" class="outline-3">
<h3 id="org0c89dbf"><span class="section-number-3">7.2.</span> A Datum based prefix syntax</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Here is the grammar for the concrete syntax.   The quote marks
enclose literal symbols.  
</p>
<pre class="example" id="org9ca3168">
&lt;exp&gt; ::= &lt;num&gt; | '(+ ' &lt;exp&gt; &lt;exp&gt;')'
</pre>
</div>
</div>


<div id="outline-container-orgc533326" class="outline-3">
<h3 id="orgc533326"><span class="section-number-3">7.3.</span> Unparser and Parser</h3>
<div class="outline-text-3" id="text-7-3">
<div class="tdl" id="org7e216d9">
<dl class="org-dl">
<dt>Unparser</dt><dd>An unparser takes an ast and returns an element
of concrete syntax.</dd>
</dl>
<dl class="org-dl">
<dt>Parser</dt><dd>A parser does the opposite: it takes a string,
determines if the string is an instance of the
concrete syntax.  If it is, the parser converts the
string to an ast.  If not, it raises an error.</dd>
</dl>

</div>
</div>
</div>

<div id="outline-container-orgd1c379d" class="outline-3">
<h3 id="orgd1c379d"><span class="section-number-3">7.4.</span> Unparsing to a datum syntax: Racket implementation</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">
<pre class="src src-racket" id="org1b2cef0">(define (unparse a)
  (cases ast a
    [num (n) n]
    [plus (left right)
          (list '+ 
                (unparse left)
                (unparse right))]))
</pre>
</div>
</div>
</div>

<div id="outline-container-org142f4b6" class="outline-3">
<h3 id="org142f4b6"><span class="section-number-3">7.5.</span> Testing <code>unparse</code></h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">
<pre class="src src-racket">(check-equal? 5 (unparse (num 5)))
(check-equal? '(+ 2 3) (unparse (plus (num 2) (num 3))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdcebff7" class="outline-3">
<h3 id="orgdcebff7"><span class="section-number-3">7.6.</span> An unparser using quasiquote</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Quasiquote (or backquote) allows controlled evaluation inside an
expression.  Evaluation inside the expression is triggered in
the context of a quasiquote and an unquote (comma).
</p>

<p>
<code>`&lt;exp&gt;</code> is short for <code>(quasiquote &lt;exp&gt;)</code>.  <code>,&lt;exp&gt;</code> is
short for <code>(unquote &lt;exp&gt;)</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket">(define (unparse/quasiquote a)
  (cases ast a
    [num (n) n]
    [plus (left right)
          `(+ 
            ,(unparse left)
            ,(unparse right))]))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4104bdd" class="outline-3">
<h3 id="org4104bdd"><span class="section-number-3">7.7.</span> An unparser that generates infix syntax</h3>
<div class="outline-text-3" id="text-7-7">
<div class="org-src-container">
<pre class="src src-racket">(define (unparse-infix a)
  (cases ast a
    [num (n) (format "~a" n)]
    [plus (left right)
          (format "(~a + ~a)" 
                  (unparse-infix left)
                  (unparse-infix right))]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5695206" class="outline-2">
<h2 id="org5695206"><span class="section-number-2">8.</span> Exercise: A datum parser</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgaebd2eb" class="outline-3">
<h3 id="orgaebd2eb"><span class="section-number-3">8.1.</span> A datum vs string parser</h3>
<div class="outline-text-3" id="text-8-1">
<dl class="org-dl">
<dt>Datum parser</dt><dd>The concrete syntax is built using datum
elements.  It is much easier to build a datum
parser because the conversion of strings of
characters to datum elements, the heavy
lifting, is already done by Racket.</dd>

<dt>String parser</dt><dd>The concrete syntax is a string.  The
parsing to ASTs involves more complex
parsing methods, usually the stuff of a
compilers course.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgb71a517" class="outline-3">
<h3 id="orgb71a517"><span class="section-number-3">8.2.</span> Does the concrete syntax determine the meaning of programs?</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>It is profitable to think of programs as trees, i.e., as
Abstract Syntax trees.</li>

<li>The concrete syntax is relevant only insofar as how it
appeals to a human reader of the program.</li>

<li>Therefore, we will pick a Racket-like syntax for the
languages we build in this course.  One advantage is that it
is already familiar to us by now.  The other advantage is
that parsers are very easy to build for such concrete syntax
in Racket.</li>
</ul>
</div>
</div>


<div id="outline-container-orgc76006b" class="outline-3">
<h3 id="orgc76006b"><span class="section-number-3">8.3.</span> A datum parser</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The datum parser for the ADDITION language is quite simple. 
</p>
<div class="org-src-container">
<pre class="src src-racket">;;; parse :: any/c -&gt; ast? + error
(define parse
  (lambda (d)
    (cond [(number? d) (num d)]
          [(and (list? d) (= (length d) 3)
                (eq? (first d) '+))
           (plus (parse (second d)) 
                 (parse (third d)))]
          [else (error 'parse 
                       "invalid syntax ~a" d)])))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8799b2f" class="outline-3">
<h3 id="org8799b2f"><span class="section-number-3">8.4.</span> Testing  <code>parse</code></h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-racket">(check-equal? (num 5) (parse 5))
(check-equal? (plus (num 4) (num 3)) (parse '(+  4 3)))
(check-exn exn:fail? (lambda () (parse '(+ "hello" 3))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org874e408" class="outline-3">
<h3 id="org874e408"><span class="section-number-3">8.5.</span> Datum parser using match</h3>
<div class="outline-text-3" id="text-8-5">
<p>
<a href="https://docs.racket-lang.org/reference/match.html"><code>match</code></a> is a construct in Racket that allows pattern-matching.
A given expression may be matched with different patterns.
<code>match</code> is a derived keyword, but the implementation of <code>match</code>
is not necessary to understand how to use it.
</p>

<div class="org-src-container">
<pre class="src src-racket">;;; parse/match :: any/c -&gt; ast? + error
;;;
(require racket/match)
(define parse/match
  (lambda (d)
    (match d
      [(? number? n) (num n)]         ; is d a number, say n?
      [(list '+ left right)           ; is d a list consisting of '+, 
                                      ; and two other parts, 
                                      ; say, left and right?
       (plus (parse/match left) 
             (parse/match right))]
      [else (error 'parse/match
                   "invalid syntax ~a" d)])))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge126131" class="outline-3">
<h3 id="orge126131"><span class="section-number-3">8.6.</span> Testing  <code>parse/match</code></h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">
<pre class="src src-racket">(check-equal? (num 5) (parse/match 5))
(check-equal? (plus (num 4) (num 3)) (parse/match '(+  4 3)))
(check-exn exn:fail? (lambda () (parse/match '(+ "hello" 3))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9d088f6" class="outline-2">
<h2 id="org9d088f6"><span class="section-number-2">9.</span> Summary</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org0e8e0f8" class="outline-3">
<h3 id="org0e8e0f8"><span class="section-number-3">9.1.</span> Key concepts in this lesson</h3>
<div class="outline-text-3" id="text-9-1">
<div class="tdl" id="org0e13a33">
<dl class="org-dl">
<dt>Concrete Syntax </dt><dd>Programs have concrete syntax.</dd>
</dl>


<dl class="org-dl">
<dt>Abstract Syntax Trees</dt><dd>The abstract syntax is the
hidden hierarchical structure beneath the concrete
syntax.</dd>
</dl>



<dl class="org-dl">
<dt>Syntax via inference rules</dt><dd>The syntax of a programming
language may be specified via judgements and inference
rules.</dd>
</dl>


<dl class="org-dl">
<dt>Racket implementation of AST as a datatype</dt><dd>An abstract
syntax tree is realised a data type consisting of variants
for each syntactic category.</dd>
</dl>


<dl class="org-dl">
<dt>Unparser</dt><dd>Converts an AST of a program to its concrete
syntax.</dd>
</dl>


<dl class="org-dl">
<dt>Parser</dt><dd>Converts a  concrete syntax of a program into
its AST.</dd>
</dl>

</div>
</div>
</div>

<div id="outline-container-org907ef1e" class="outline-3">
<h3 id="org907ef1e"><span class="section-number-3">9.2.</span> Key Racket concepts in this lesson</h3>
<div class="outline-text-3" id="text-9-2">
<div class="tdl" id="orge7a7a20">
<dl class="org-dl">
<dt><code>define-datatype</code></dt><dd>A way of defining variant abstract
data types (inherited from EOPL).</dd>
</dl>


<dl class="org-dl">
<dt><code>quasiquote</code> and <code>unquote</code></dt><dd>Ways of controlling
evaluation within an  expression.</dd>
</dl>


<dl class="org-dl">
<dt><code>match</code></dt><dd>A pattern matcher for datums.</dd>
</dl>

</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Venkatesh Choppella</p>
<p class="date">Created: 2024-08-15 Thu 16:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
