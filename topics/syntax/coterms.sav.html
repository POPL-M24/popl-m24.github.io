<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-08-15 Thu 16:56 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coinduction and  Term Graphs</title>
<meta name="author" content="Venkatesh Choppella" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script src="../../themes/math/style/js/math.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="../../themes/math/style/css/math.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/extra.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/js/readtheorg.js"></script>
<div style="display: none"> \(
% Latex Preamble definitions here (mostly usepackage)
\usepackage%
%[dvipsnames]
{xcolor}
% make sure this is before the loading font packages
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage
%[dvipsnames]
{graphicx}
\usepackage{float}
%\usepackage[numbers]{natbib}
\usepackage[document]{ragged2e}
%
% enumitem doesn't seem to work with beamer
%\usepackage[inline]{enumitem}
\usepackage{wrapfig}
\usepackage{stackrel}
% extensible arrows
\usepackage{extpfeil}
% \usepackage{trfrac}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{automata, positioning, arrows, shapes.geometric}
\usepackage{turnstile}
\usepackage{comment}
%https://tex.stackexchange.com/questions/21334/is-there-a-package-that-has-the-clockwise-gapped-circle-arrow-in-it
% \usepackage{mathbx}
\usepackage{datetime}
\usepackage{datetime2}

%% Also See
%% http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% for general tips
\usepackage{listings}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{amsfonts} %% - also included by amssymb
\usepackage{mathpazo} %% - because the OP uses mathpazo, optional
%\usepackage{tufte-latex}
\usepackage{comment}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{hyperref}
%\usepackage{cleveref}
\)</div>
<div style="display: none"> \(
%% Your math definitions here
% \newcommand{\alphaequiv}{{\underset{\raise 0.7em\alpha}{=}}}
\newcommand{\yields}{\Rightarrow}
\newcommand{\derives}{\overset{*}{\yields}}
\newcommand{\alphaequiv}{=_{\alpha}}
\newcommand{\tto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\transitsto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\xtransitsto}[2]{{\underset{#2}{\xrightarrow{#1}}}}
\newcommand{\xtransitsfrom}[2]{{\underset{#2}{\xleftarrow{#1}}}}
\newcommand{\xto}[2]{{\xtransitsto{#1}{#2}}}
\newcommand{\xfrom}[2]{{\xtransitsfrom{#1}{#2}}}
\newcommand{\xreaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
\newcommand{\reaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
%\newcommand{\reaches}[2]{{\overset{#1}{\underset{#2}{\twoheadrightarrow}}}}
%\newcommand{\goesto}[2]{\transitsto{#1}{#2}}
%\newcommand{\betareducesto}{{\underset{\beta}{\rightarrow}}}
\newcommand{\betareducesto}{\rightarrow_{\beta}}
%\newcommand{\etareducesto}{{\underset{\eta}{\rightarrow}}}
\newcommand{\etareducesto}{\rightarrow_{\eta}}
%\newcommand{\betaetareducesto}{{\underset{\beta\ \eta}{\rightarrow}}}
\newcommand{\betaetareducesto}{\rightarrow_{\beta\eta}}
\newcommand{\preducesto}{\rhd}
\newcommand{\psimplifiesto}{\stackrel{\scriptstyle{*}}{\rhd}}
\newcommand{\lreducesto}{\rightsquigarrow}
\newcommand{\lsimplifiesto}{\stackrel{\scriptstyle{*}}{\lreducesto}}
\newcommand{\rewritesto}{\hookrightarrow}
\newcommand{\goesto}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\xgoesto}[1]{\xrightarrow{#1}}
\newcommand{\reducesto}{\stackrel{}{\rightarrow}}
\newcommand{\simplifiesto}{\stackrel{\scriptstyle{*}}{\rightarrow}}
\newcommand{\connected}[1]{\stackrel{#1}{\leftrightarrow}}
\newcommand{\joins}{\downarrow}
\newcommand{\evaluatesto}{\Longrightarrow}
%\newcommand{\lit}[1]{\hbox{\sf{#1}}}
\newcommand{\lit}[1]{{\sf{#1}}}
\newcommand{\true}{\lit{true}}
\newcommand{\false}{\lit{false}}
\def\Z{\mbox{${\mathbb Z}$}}
\def\N{\mbox{${\mathbb N}$}}
\def\P{\mbox{${\mathbb P}$}}
\def\R{\mbox{${\mathbb R}$}}
\def\T{\mbox{${\mathbb T}$}}
\newcommand{\Rp}{{\mathbb{R}}^+}
\def\Bool{\mbox{${\mathbb B}$}}
\def\Q{\mbox{${\mathbb Q}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sL{\mbox{${\cal L}$}}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\sR{\mbox{${\cal R}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sO{\mbox{${\cal O}$}}
\def\sT{\mbox{${\cal T}$}}
\def\sU{\mbox{${\cal U}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\osum{${{\bigcirc}}\!\!\!\!{\rm s}~$}
\def\pf{\noindent {\bf Proof}~~}
\def\exec{\mathit{exec}}
\def\Act{\mathit{A\!ct}}
\def\Traces{\mathit{Traces}}
\def\Spec{\mathit{Spec}}
\def\uns{\mathit{unless}}
\def\ens{\mathit{ensures}}
\def\lto{\mathit{leads\!\!-\!\!to}}
\def\a{\alpha}
\def\b{\beta}
\def\c{\gamma}
\def\d{\delta}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sI{\mbox{${\cal I}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sR{\mbox{${\cal R}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\ta{\mbox{$\widetilde{a}$}}
\def\tb{\mbox{$\widetilde{b}$}}
\def\tc{\mbox{$\widetilde{c}$}}
\def\tx{\mbox{$\widetilde{x}$}}
\def\ty{\mbox{$\widetilde{y}$}}
\def\tz{\mbox{$\widetilde{z}$}}
\def\tI{\mbox{$\widetilde{I}$}}
\def\norm{\mbox{$\parallel$}}
\def\sL{\mbox{${\cal L}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\to{\rightarrow}
\def\ov{\overline}
\def\gets{\leftarrow}
\def\too{\longrightarrow}
\def\To{\Rightarrow}
%\def\points{\mapsto}
%\def\yields{\mapsto^{*}}
\def\un{\underline}
\def\vep{$\varepsilon$}
\def\ep{$\epsilon$}
\def\tri{$\bigtriangleup$}
\def\Fi{$F^{\infty}$}
\def\Di{\Delta^{\infty}}
\def\ebox\Box
\def\emp{\emptyset}
\def\leadsto{\rightharpoondown^{*}}

\newcommand{\benum}{\begin{enumerate}}
\newcommand{\eenum}{\end{enumerate}}
\newcommand{\bdes}{\begin{description}}
\newcommand{\edes}{\end{description}}
\newcommand{\bt}{\begin{theorem}}
\newcommand{\et}{\end{theorem}}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
% \newcommand{\bp}{\begin{prop}}
% \newcommand{\ep}{\end{prop}}
\newcommand{\bd}{\begin{defn}}
\newcommand{\ed}{\end{defn}}
\newcommand{\brem}{\begin{remark}}
\newcommand{\erem}{\end{remark}}
\newcommand{\bxr}{\begin{exercise}}
\newcommand{\exr}{\end{exercise}}
\newcommand{\bxm}{\begin{example}}
\newcommand{\exm}{\end{example}}
\newcommand{\beqa}{\begin{eqnarray*}}
\newcommand{\eeqa}{\end{eqnarray*}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bcent}{\begin{center}}
\newcommand{\ecent}{\end{center}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\bcor}{\begin{corollary}}
\newcommand{\ecor}{\end{corollary}}
\newcommand{\bds}{\begin{defns}}
\newcommand{\eds}{\end{defns}}
\newcommand{\brems}{\begin{remarks}}
\newcommand{\erems}{\end{remarks}}
\newcommand{\bxrs}{\begin{exercises}}
\newcommand{\exrs}{\end{exercises}}
\newcommand{\bxms}{\begin{examples}}
\newcommand{\exms}{\end{examples}}
\newcommand{\bfig}{\begin{figure}}
\newcommand{\efig}{\end{figure}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\pair}[1]{\langle #1\rangle}
\newcommand{\tuple}[1]{\langle #1\rangle}
\newcommand{\size}[1]{| #1 |}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersection}{\cap}
\newcommand{\Intersection}{\bigcap}
\newcommand{\B}{\textbf{B}}
%\newcommand{\be}[2]{\begin{equation} \label{#1} \tag{#2} \end{equation}}
\newcommand{\abs}[1]{{\lvert}#1{\rvert}}
\newcommand{\id}[1]{\mathit{#1}}
\newcommand{\pfun}{\rightharpoonup}
%\newcommand{\ra}[1]{\kern-1.5ex\xrightarrow{\ \ #1\ \ }\phantom{}\kern-1.5ex}
%\newcommand{\ras}[1]{\kern-1.5ex\xrightarrow{\ \ \smash{#1}\ \ }\phantom{}\kern-1.5ex}
\newcommand{\da}[1]{\bigg\downarrow\raise.5ex\rlap{\scriptstyle#1}}
\newcommand{\ua}[1]{\bigg\uparrow\raise.5ex\rlap{\scriptstyle#1}}
% \newcommand{\lift}[1]{#1_{\bot}}
\newcommand{\signal}[1]{\tilde{#1}}
\newcommand{\ida}{\stackrel{{\sf def}}{=}}
\newcommand{\eqn}{\doteq}
\newcommand{\deduce}[1]{\sststile{#1}{}}

%% These don't sit very well with MathJax
%% so we don't plan to use theorem like environments
%% in org documents.
%% instead we plan to use headings with
%%  1. property drawers with a CLASS property identifying
%%  the environment
%%  2. A tag with the same name as the CLASS property
%%  In LaTeX export, these turn into (sub)sections.


%% See http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% \newtheorem{prop}[thm]{Proposition}
%% \theoremstyle{plain}%default
%% \newtheorem{theorem}{Theorem}[section]
%% \newtheorem{lemma}{Lemma}[section]
%% \newtheorem{corollary}{Corollary}[section]
%% \newtheorem{definition}{Definition}[section]
%% \newtheorem{remark}{Remark}[section]
%% \newtheorem{example}{Example}[section]
%% \newtheorem{exercise}{Exercise}[section]



\newcommand{\less}[1]{#1_{<}}
\newcommand{\pfn}{\rightharpoonup}
\newcommand{\ffn}{\stackrel{{\sf fin}}{\rightharpoonup}}
\newcommand{\stkout}[1]{\ifmmode\text{\sout{\ensuremath{#1}}}\else\sout{#1}\fi}

% Caution: Not supported by MathJax!
% ----------------------------------
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}


% \usepackage{amsfonts} %% <- also included by amssymb
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}
\usepackage{mathpazo} %% <- because the OP uses mathpazo, optional



\newcommand{\mbf}[1]{\mathbf{#1}}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\rel}{\twoheadrightarrow}
\newcommand{\map}{\rightarrow}

%\newcommand{\fixed}{\boldsymbol{\circlearrowleft}}
\newcommand{\terminal}{\not\xto{}{}}
\newcommand{\fixed}{\bm\circlearrowleft}

\newcommand{\imp}{\rightarrow}
\newcommand{\dimp}{\leftrightarrow}  % double implication
\newcommand{\lequiv}{\Longleftrightarrow} % logical equivalence
\newcommand{\limplies}{\Rightarrow}
\newcommand{\lxor}{\veebar}
\)</div>
<link rel="icon" type="image/png" href="../../themes/popl/style/img/favicon/popl.png" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'left',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    output: {
      font: 'mathjax-euler',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Coinduction and  Term Graphs</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc996121">1. Introduction</a>
<ul>
<li><a href="#orge1c4c06">1.1. Terms as fixed points</a></li>
</ul>
</li>
<li><a href="#orgc8b84e9">2. Notation and basic definitions</a>
<ul>
<li><a href="#org46f7b04">2.1. Currying</a></li>
<li><a href="#org051088a">2.2. Set membership</a></li>
<li><a href="#org3eb218b">2.3. Index and positions</a></li>
<li><a href="#orgf7b5348">2.4. Partial Functions</a></li>
</ul>
</li>
<li><a href="#org1e75174">3. Signature</a>
<ul>
<li><a href="#org5228ab8">3.1. Signature</a></li>
<li><a href="#orgdc99f70">3.2. An example signature</a>
<ul>
<li><a href="#org51a5494">3.2.1. Example signature</a></li>
<li><a href="#orgf879e1e">3.2.2. Racket implementation of example signature</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8316be5">4. Inductive terms</a>
<ul>
<li><a href="#orgdf5ddcf">4.1. Definition</a></li>
<li><a href="#org40c5b8b">4.2. Well-foundedness property</a></li>
</ul>
</li>
<li><a href="#orgfc87ca6">5. Term graphs</a>
<ul>
<li><a href="#org038c72e">5.1. Term Graph</a></li>
<li><a href="#org0e43e91">5.2. Reachability and Destination</a></li>
<li><a href="#org7cd9fe0">5.3. Term graph as a Flat System of Equations</a></li>
</ul>
</li>
<li><a href="#orgd1fd1a1">6. Inductive term graphs</a>
<ul>
<li><a href="#org52467d3">6.1. Solution</a></li>
<li><a href="#term-tree">6.2. Example</a>
<ul>
<li><a href="#orgef22ec5">6.2.1. Solution to \(G\)</a></li>
<li><a href="#orgd09f25d">6.2.2. Racket implementation of solution</a></li>
</ul>
</li>
<li><a href="#orgbae5f79">6.3. Proposition:  Every inductive term graph has a unique solution</a></li>
</ul>
</li>
<li><a href="#org319b1eb">7. Motivating Terms</a>
<ul>
<li><a href="#orged693b7">7.1. Inductive terms are solutions for inductive term graphs</a></li>
<li><a href="#orgdadc11a">7.2. Inductive terms can not be solutions for cyclic term graphs</a></li>
</ul>
</li>
<li><a href="#orgf368918">8. (Coinductive) Terms</a>
<ul>
<li><a href="#org773a20f">8.1. Observations and interactions</a></li>
<li><a href="#orgbacb3cd">8.2. Position space</a>
<ul>
<li><a href="#org654b43d">8.2.1. Position space of a vertex in a term graph</a></li>
<li><a href="#org390d543">8.2.2. Example of a position space</a></li>
</ul>
</li>
<li><a href="#org4bf3646">8.3. Behaviour</a>
<ul>
<li><a href="#org6370a27">8.3.1. Behaviour over a signature</a></li>
<li><a href="#orgf27bc18">8.3.2. The concatenation of an index with a behaviour</a></li>
<li><a href="#ex-behaviour">8.3.3. Examples of behaviours</a></li>
</ul>
</li>
<li><a href="#org75e9b0b">8.4. Composing Behaviours</a>
<ul>
<li><a href="#ex-bhvr-comp">8.4.1. Example</a></li>
</ul>
</li>
<li><a href="#org5a01820">8.5. Coinductive Terms as Behaviour</a></li>
<li><a href="#obs-bhvr-vtx">8.6. Observable behaviour of a vertex in a term graph</a></li>
<li><a href="#org0ca5a50">8.7. Example illustrating observable behaviour</a></li>
<li><a href="#solution-term-graph">8.8. Solution of a term graph</a></li>
<li><a href="#org29bfb60">8.9. Proposition (Solution Lemma)</a>
<ul>
<li><a href="#org9904760">8.9.1. Proof</a>
<ul>
<li><a href="#orgd36bf08">8.9.1.1. Existence</a></li>
<li><a href="#org728d84e">8.9.1.2. Uniqueness</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9f34f11">8.10. Coinductive terms as denotations of vertices in a term graph</a></li>
<li><a href="#orga37ac8d">8.11. Comparing inductive and coinductive terms over a signature</a></li>
<li><a href="#org37ad98c">8.12. Unique solution (from the theory of hypersets)</a></li>
<li><a href="#org968be1f">8.13. More examples</a>
<ul>
<li><a href="#term-dag">8.13.1. Term DAG</a></li>
<li><a href="#inf">8.13.2. Infinite Term Graph</a></li>
<li><a href="#cyc">8.13.3. Cyclic Term graph</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0ddf1ec">9. Reasoning about Equality of Terms via Bisimulation</a>
<ul>
<li>
<ul>
<li><a href="#bicycle">9.0.1. Example of circular reasoning</a></li>
</ul>
</li>
<li><a href="#org5dd0c04">9.1. Definition of Bisimulation</a></li>
<li><a href="#org9bd6b41">9.2. Examples</a>
<ul>
<li><a href="#ind_equal">9.2.1. Reasoning about equality based on induction</a></li>
<li><a href="#bisim_equal">9.2.2. Reasoning about equality based on bisimulation, or co-induction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org45805bf">10. Replacement</a>
<ul>
<li><a href="#org90abf7f">10.1. Replacement</a>
<ul>
<li><a href="#cycrep">10.1.1. Example: replacement involving cycles</a></li>
</ul>
</li>
<li><a href="#org06824cf">10.2. Defining subterm and replacement</a>
<ul>
<li><a href="#org121e226">10.2.1. Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org72756f5">11. Implementing term graphs and replacement in Racket</a>
<ul>
<li><a href="#orgf029b7f">11.1. Inductive term</a></li>
<li><a href="#org4224dac">11.2. Coinductive terms</a></li>
<li><a href="#orge81511b">11.3. Index</a></li>
<li><a href="#org40eda0f">11.4. Term reference</a></li>
<li><a href="#org5dcd764">11.5. Position</a></li>
<li><a href="#org4a7453f">11.6. Subterm</a></li>
<li><a href="#org52a9ae5">11.7. Replacement in a flat list</a>
<ul>
<li><a href="#orgc9df3cc">11.7.1. <code>replace-flat</code> definition</a></li>
</ul>
</li>
<li><a href="#orga9c445b">11.8. Replace</a>
<ul>
<li><a href="#orgc0f4781">11.8.1. Implementing <code>replace</code></a></li>
</ul>
</li>
<li><a href="#org9bad3b9">11.9. Boilerplate</a></li>
</ul>
</li>
<li><a href="#org9f56221">12. Implementing Bisimulation for Rational terms</a>
<ul>
<li><a href="#org491c0f7">12.1. Test cases</a></li>
<li><a href="#org225c2a8">12.2. Implementation</a></li>
</ul>
</li>
<li><a href="#org1c3c282">13. References</a>
<ul>
<li><a href="#orgc4584e4">13.1. Induction</a></li>
<li><a href="#org0777d68">13.2. Coinduction</a></li>
<li><a href="#org0a69273">13.3. Knaster Tarski Theorem</a></li>
<li><a href="#orgac1c582">13.4. Solution Lemma and non-well-founded set theory</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgc996121" class="outline-2">
<h2 id="orgc996121"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Recall the notion of finite, or inductively defined terms.
Each inductively defined term may be identified by a tree.
In this writeup, we revisit terms in a more general setting
here, one that includes both finite and infinite terms,
represented by not only trees but (finite or infinite)
graphs.  These more general terms are known by different
names: <i>co-inductive terms</i>, <i>coterms</i>, or <i>term graphs</i>.
We will use these names interchangeably.
</p>

<p>
The study of coinductive terms may be approached from
multiple mathematical perspectives.  They may be seen final
co-algebras in category theory.  They may be interpreted as
the largest fixed points of a signature operator.  They can
also be thought of as non-well-founded sets in
non-well-founded set theory.  They may be interpreted as
finite or infinite labeled directed graphs.  The approach we
take here is to connect terms with <i>behaviour</i> expressed as
a function that maps a sequence of interactions to an
observation that is closely related to their graphical
representation.  This `systems' approach is attractive for
two reasons: first, it builds on material that you are
already familiar with: graphs and functions.  Second, it
situates terms in the wider context of interactive abstract
machines, which we will encounter in different avatars
during this course. 
</p>
</div>

<div id="outline-container-orge1c4c06" class="outline-3">
<h3 id="orge1c4c06"><span class="section-number-3">1.1.</span> Terms as fixed points</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Let \(A\) be any set.  \(\Sigma(A)\) is the set \(\set{(f, a_1,
\ldots, a_n)\ |\ f\in \Sigma, \alpha(f)=n, a_i\in A}\).  The
element \((f, a_1, \ldots, a_n)\) is usually written \(f(a_1,
\ldots, a_n)\).  The function \(\id{hd}:\Sigma(A) \rightarrow
\Sigma\), takes a tuple in \(\Sigma(A)\) and returns its first
element, called head, which belongs to \(\Sigma\).
</p>

<p>
Let's examine the operator \(\Sigma\) (not to be confused with
the <i>alphabet</i> &Sigma;) a bit more closely: \(\Sigma\) is an
example of a set operator.  (Formally, \(\Sigma\) is an
example of a endofunctor in the category of sets, but we do
not need worry about that here.)
</p>

<p>
Now, consider the following <i>fixed point equation</i>:
</p>

<p>
\[X = \Sigma(X)\]
</p>

<p>
Is there a fixed point of \(\Sigma\), i.e., an \(X\) satisfying
the above equation?  Let's assume for the moment there is
indeed a set \(X\) and examine the consequences of that
assumption.  Then the equality between the two sets on the
left and right side of the equations may be broken down into
two propositions: \(\Sigma(X)\subseteq X\) and \(X\subseteq
\Sigma(X)\).  Going right to left, we have
\(\Sigma(X)\subseteq X\).  Let's pick an element in
\(\Sigma(X)\).  By definition, it is a tuple \((f, x_1, \ldots,
x_n)\) where \(f\in \Sigma^{(n)}\) and \(x_i\in X\) for each \(i\),
\(1\leq i \leq n\).  What \(\Sigma(X)\subseteq X\) means is that
the tuple \((f, x_1, \ldots, x_n)\) is also in \(X\).
</p>

<p>
Going left to write this implies \(X\subseteq \Sigma(X)\).
Any element \(t\) in \(X\) is in \(\Sigma(X)\).  But every element
in \(\Sigma(X)\) is of the form \(f(t_1,\ldots, t_n)\) for some
\(f\in \Sigma^{(n)}\) and \(t_i\in X\) for \(1\leq i\leq n\).  All
we are saying is every element of \(X\) has a `shape': it is a
tuple consisting of a constructor \(f\) of arity \(n\) for some
\(n\), following by \(n\) other things that are each in \(X\).  
</p>

<p>
Now, let's come back to the question of whether the fixed
point solution above has any solutions at all or not.  It
turns out that \(\Sigma\) has certain properties that
guarantee that it has multiple fixed points.  Furthermore,
these solutions are ordered (via set inclusion) and that
there is a least solution and a largest solution in this
ordering.  We will skip going into the properties of
\(\Sigma\) and how those guarantee solutions to the fixed
point equation.  That will take us into fixed point theory
and the Knaster-Tarski theorem.  The references have
pointers to some of the relevant papers.
</p>

<p>
It turns out that the least solution is the set of all
finite, or <i>inductive</i> $&Sigma;$-terms.  The largest solution
is the set of all finite and infinite $&Sigma;$-terms, or
<i>coinductive</i> terms.  Note that the coinductive terms
include the inductive terms.  To see an example of a
coinductive term that is not inductive, consider for example
\(\Sigma\) consisting of \({\sf g}\) and \({\sf a}\) with arities
1 and 0 respectively.  Then, we can imagine not only
finite terms like \({\sf g(a)}\) and \({\sf g(g(a))}\) but
also infinite terms like \({\sf g(g(g(\ldots)))}\).
</p>
</div>
</div>
</div>


<div id="outline-container-orgc8b84e9" class="outline-2">
<h2 id="orgc8b84e9"><span class="section-number-2">2.</span> Notation and basic definitions</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org46f7b04" class="outline-3">
<h3 id="org46f7b04"><span class="section-number-3">2.1.</span> Currying</h3>
<div class="outline-text-3" id="text-2-1">
<p>
For the sake of clarity, we will use curried notation for
function application.  \(f(x)\) will frequently be written as
\(f\ x\) and \(f\ x\ y\) or \(f(x)(y)\) will mean \((f(x))(y)\).
Occasionally, this could lead to ambiguity, e.g., when we
wish to represent \(x\ y\) as the concatenation of \(x\) and
\(y\).  In such cases, ambiguity will be resolved by
clarification of the specific use.
</p>
</div>
</div>

<div id="outline-container-org051088a" class="outline-3">
<h3 id="org051088a"><span class="section-number-3">2.2.</span> Set membership</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The Colon symbol \((:)\) will be used interchangeably with
\(\in\) to denote membership: \(x:A\) is identical to \(x\in A\).
</p>
</div>
</div>

<div id="outline-container-org3eb218b" class="outline-3">
<h3 id="org3eb218b"><span class="section-number-3">2.3.</span> Index and positions</h3>
<div class="outline-text-3" id="text-2-3">
<p>
\(\N\) denotes the set of natural numbers.  \(\N_1\) denotes the
set of positive natural numbers.  An <i>index</i> is a positive
natural number.  Let \(m:\N\) denote a natural number.
\(\N_1(m)\) denotes the subset of \(\N_1\) consisting of indices
less than or equal to \(m\).  Note that \(\N_1(0)\) is empty.
</p>
</div>
</div>

<div id="outline-container-orgf7b5348" class="outline-3">
<h3 id="orgf7b5348"><span class="section-number-3">2.4.</span> Partial Functions</h3>
<div class="outline-text-3" id="text-2-4">
<p>
If \(f:A\pfn B\) is a partial function from \(A\) to \(B\), then
\(A\) and \(B\) are called the <i>domain</i> and the <i>codomain</i> of
\(f\) and denoted \(\id{dom}\ f\) and \(\id{cod}\ f\),
respectively.    The <i>domain
of definition</i> of \(f\), written \(\id{dod}\ f\) is the set
\({x\in A\ |\ \exists y\in B. y=f\ x}\).  The <i>range</i> of \(f\),
denoted \(\id{rng}\ f\) is the set of all \(y\in B\) such that
there is an \(x\in A\) such that \(f\ x=y\).  
</p>
</div>
</div>
</div>

<div id="outline-container-org1e75174" class="outline-2">
<h2 id="org1e75174"><span class="section-number-2">3.</span> Signature</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org5228ab8" class="outline-3">
<h3 id="org5228ab8"><span class="section-number-3">3.1.</span> Signature</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A <i>signature</i> \(\Sigma\) is a finite set of <i>constructor</i>
symbols along with an <i>arity</i> function
\(\alpha:\Sigma\rightarrow \N\).  We write \(\Sigma^{(n)}\) to
denote the set of all constructors that have arity \(n\).  A
constructor is said to be <i>nullary</i> if its arity is zero.
</p>
</div>
</div>

<div id="outline-container-orgdc99f70" class="outline-3">
<h3 id="orgdc99f70"><span class="section-number-3">3.2.</span> An example signature</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org51a5494" class="outline-4">
<h4 id="org51a5494"><span class="section-number-4">3.2.1.</span> Example signature</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Consider the signature \(\Sigma = \set{{\sf a}, {\sf g}, {\sf
f}}\) with \(\alpha({\sf a})=0\) and \(\alpha({\sf g})=1\) and
\(\alpha({\sf f})=2\).  We will use this signature for the
examples in this lesson. 
</p>
</div>
</div>

<div id="outline-container-orgf879e1e" class="outline-4">
<h4 id="orgf879e1e"><span class="section-number-4">3.2.2.</span> Racket implementation of example signature</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
In a Racket implementation, each constructor is simply
functions that create lists consisting of a head symbol and
other arguments.  We call the results of the construction as
<i>terms</i>.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="org911bee4">(define (a) (list 'a))
(define (b) (list 'b))
(define (g t) (list 'g t))
(define (f t1 t2) (list 'f t1 t2))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8316be5" class="outline-2">
<h2 id="org8316be5"><span class="section-number-2">4.</span> Inductive terms</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgdf5ddcf" class="outline-3">
<h3 id="orgdf5ddcf"><span class="section-number-3">4.1.</span> Definition</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The set of \(T_{\sf ind}(\Sigma)\) of <i>inductive terms over</i> a
signature \(\Sigma\) is inductively defined using the
following rule:
\[
\frac{\tau_1:T_{\sf ind}(\Sigma)\quad \ldots \quad
\tau_n:T_{\sf ind}(\Sigma)}
{f(\tau_1, \ldots, \tau_n)\ : T_{\sf ind}(\Sigma)}
\quad f:\Sigma^{(n)}\qquad CONS
\]
</p>

<p>
The structure \(f(\tau_1, \ldots, \tau_n)\) is a more
traditional syntax for the list \((f, \tau_1, \ldots,
\tau_n)\).  We will continue to use the former notation in
our narrative, but switch to the latter (<i>sans</i> commas!) when
implementing terms in Racket.
</p>

<p>
The inductive terms \(\tau_1, \ldots \tau_n\) are called
<i>proper subterms</i> of \(f(\tau_1, \ldots, \tau_n)\).  
</p>
</div>
</div>


<div id="outline-container-org40c5b8b" class="outline-3">
<h3 id="org40c5b8b"><span class="section-number-3">4.2.</span> Well-foundedness property</h3>
<div class="outline-text-3" id="text-4-2">
<p>
It is not possible to have an inductive term \(\tau\) such
that \(\tau\) is a proper subterm of itself.  (Exercise: prove
it).
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc87ca6" class="outline-2">
<h2 id="orgfc87ca6"><span class="section-number-2">5.</span> Term graphs</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org038c72e" class="outline-3">
<h3 id="org038c72e"><span class="section-number-3">5.1.</span> Term Graph</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Let \(\N_1\) denote the set of positive integers.  A <i>term
graph</i> over a signture \(\Sigma\) is a tuple \(\pair{V, h,
\xto{}{}}\) where
</p>

<ol class="org-ol">
<li>\(V\) is a (countable) set of <i>vertices</i>.</li>

<li>\(h\) is the <i>head</i> function mapping \(V\) to \(\Sigma\).</li>

<li>\(\xto{}{} \subseteq V\times \N_1\times V\) is a
<i>transition</i> relation.  We write \((v, i, v')\) as
\(v\xto{i}{}v'\).   We say that \(i\) takes \(v\) to \(v'\).</li>

<li>If \(h(v)\in \Sigma^{(n)}\), then \(v\) has exactly \(n\)
out-edges.  For each \(i\), \(1\leq i \leq n\), there is
exactly one out-edge labeled \(i\).</li>
</ol>
</div>
</div>


<div id="outline-container-org0e43e91" class="outline-3">
<h3 id="org0e43e91"><span class="section-number-3">5.2.</span> Reachability and Destination</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Assume a term graph \(G\) with vertices \(v\) and \(v'\).  Let \(p\)
denote an index sequence.  \(v\xto{p}{G}{v'}\) means that
there is a path from \(v\) to \(v'\) whose label is \(p\).  We say
that \(p\) takes \(v\) to \(v'\).  Another way of saying this is
that \(v'\) is <i>reachable</i> from \(v\) via \(p\).
</p>

<p>
The path relation may be defined inductively.  
</p>
\begin{align*}
 \frac{}{v\xto{[\ ]}{G}v} & \qquad\qquad \text{REF}\\ \\
 \frac{v_i\xto{p}{G}v'}{v\xto{[i\ .\ p]}{G}v'}\quad v\xto{i}{G}v_i & \qquad \text{TRANS}
\end{align*}

<p>
It is not hard to see that since \(G\) is a term graph,
\(v\xto{p}{G}r\) is in fact a function: if \(v\xto{p}{G}s\),
then \(r=s\).  (Exercise: prove this.)  
</p>

<p>
If \(v\) is a vertex in a term graph \(G\), then \(\id{pos}_G\ v\)
denotes the set of <i>positions</i> for \(v\), i.e., the set of all
index sequences \(p\) such that \(v\xto{p}{G}v'\) for some
vertex \(v'\) in \(G\).  \(\id{dest}_G\ v\) maps a position in
\(\id{pos}_G\ v\) to the unique vertex that is reachable from
\(v\) via \(p\).  We drop the subscript \(G\) when it is clear
from the context.
</p>
</div>
</div>


<div id="outline-container-org7cd9fe0" class="outline-3">
<h3 id="org7cd9fe0"><span class="section-number-3">5.3.</span> Term graph as a Flat System of Equations</h3>
<div class="outline-text-3" id="text-5-3">
<p>
If \(h(v)=f\) and \(f\in \Sigma^{(n)}\) and \(v\xto{i}{G}v_i\),
for each \(i:1\leq i\leq n\), then we denote this by the
relation
</p>

<p>
\[v \eqn f(v_1, \ldots, v_n)\]
</p>

<p>
to indicate that (a) \(\id{hd}(v)=f\), (b) \(f\in
\Sigma^{(n)}\), and (c) for each \(i\) \(1\leq i\leq n\),
\(v\xto{i}{G}v_i\).  
</p>

<p>
The above looks like an equation if we interpret the
vertices as variables.  In particular, the relation element
is a `flat term equation', since the constructor is applied
to other vertices.  A term graph may be completely specified
by a system of such `flat term equations' with one equation
for each vertex in the term graph.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd1fd1a1" class="outline-2">
<h2 id="orgd1fd1a1"><span class="section-number-2">6.</span> Inductive term graphs</h2>
<div class="outline-text-2" id="text-6">
<p>
A term graph \(G\) is <i>inductive</i> if it is finite and acyclic.
There is a hierarchy (non-circular relationship) between
vertices.   
</p>
</div>

<div id="outline-container-org52467d3" class="outline-3">
<h3 id="org52467d3"><span class="section-number-3">6.1.</span> Solution</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A <i>solution</i> to an inductive term graph over \(\Sigma\) is a
map \(\sigma\) from \(V_G\) to inductive terms over \(\Sigma\)
that `solves' the flat system of equations: i.e., for each
`flat equation' \(v \eqn f(v_i, \ldots, v_n)\) in \(G\):
</p>

<p>
\[\sigma\ v = f(\sigma\ v_1, \ldots, \sigma\ v_n)\]
</p>
</div>
</div>

<div id="outline-container-term-tree" class="outline-3">
<h3 id="term-tree"><span class="section-number-3">6.2.</span> Example</h3>
<div class="outline-text-3" id="text-term-tree">
<p>
The inductive term graph \(G\) and its representation as a
system of equations is shown below:
</p>
<div class="multicol" id="org219fa80">
<div class="foo" id="orgd781cb1">

<div id="orgcca4df7" class="figure">
<p><img src="./figs/tree.png" alt="tree.png" width="200px">
</p>
</div>

</div>

<div class="foo" id="orgaec17bd">
\begin{align*}
t_1 &\eqn {\sf f}(t_2, t_3)\\
t_2 &\eqn {\sf g}(t_4)\\
t_3 &\eqn {\sf a}\\
t_4 &\eqn {\sf a}
\end{align*}

</div>

</div>
</div>

<div id="outline-container-orgef22ec5" class="outline-4">
<h4 id="orgef22ec5"><span class="section-number-4">6.2.1.</span> Solution to \(G\)</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
The following map solves \(G\). (Exercise.  Verify this.)
</p>
\begin{align*}
t_1 &\mapsto {\sf f(g(a), a)}\\
t_2 &\mapsto {\sf g(a)}\\
t_3 &\mapsto {\sf a}\\
t_4 &\mapsto {\sf a}
\end{align*}
</div>
</div>

<div id="outline-container-orgd09f25d" class="outline-4">
<h4 id="orgd09f25d"><span class="section-number-4">6.2.2.</span> Racket implementation of solution</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
In Racket, the solution is automatically based on Racket's
implementation of inductive terms and its evaluation
process.  The Racket keyword <code>let*</code> is a shortcut for nested
<code>let</code> expressions.
</p>

<div class="org-src-container">
<pre class="src src-racket">(let* ([t4 (a)]
       [t3 (a)]
       [t2 (g t4)]
       [t1 (f t2 t3)])
  (check-false (eq? t3 t4))           
  (check-equal? t1 '(f (g (a)) (a)))) 
</pre>
</div>


<p>
We can clearly see that inductive terms are just nested
lists whose head element is a constructor symbol and whose
remaining elements if any are also inductive terms.
</p>
</div>
</div>
</div>



<div id="outline-container-orgbae5f79" class="outline-3">
<h3 id="orgbae5f79"><span class="section-number-3">6.3.</span> Proposition:  Every inductive term graph has a unique solution</h3>
<div class="outline-text-3" id="text-6-3">
<p>
<b>Proof</b>:  left as an exercise.
</p>
</div>
</div>
</div>

<div id="outline-container-org319b1eb" class="outline-2">
<h2 id="org319b1eb"><span class="section-number-2">7.</span> Motivating Terms</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orged693b7" class="outline-3">
<h3 id="orged693b7"><span class="section-number-3">7.1.</span> Inductive terms are solutions for inductive term graphs</h3>
<div class="outline-text-3" id="text-7-1">
<p>
So far, we have seen inductive terms and term graphs.  We
have seen that each vertex of an inductive term graph may be
interpreted as a inductive term.  
</p>
</div>
</div>

<div id="outline-container-orgdadc11a" class="outline-3">
<h3 id="orgdadc11a"><span class="section-number-3">7.2.</span> Inductive terms can not be solutions for cyclic term graphs</h3>
<div class="outline-text-3" id="text-7-2">
<p>
But what about terms graphs that are not inductive?  For
such graphs, the notion of solution based on inductive terms
we have defined so far no longer holds:
</p>

<p>
Consider for example the equation representing the cyclic
term graph \(G\) below.
</p>
\begin{align*}
t &\eqn {\sf g}(t)
\end{align*}

<p>
Let \(\sigma = \set{t\mapsto \tau}\) where \(\tau\) is an
inductive term.  Suppose \(\sigma\) is a solution of \(G\).
Then, we should have
</p>
\begin{align*}
\sigma(t) &= {\sf g}(\sigma(t)), \qquad \text{or}\\
\tau &= {\sf f}(\tau)
\end{align*}

<p>
Clearly \(\tau\) does not exist, as this violates the
well-foundedness property of inductive terms.  Therefore,
for cyclic term graphs can not have solutions that consist
only of inductive terms.  But can they have solutions that
are not inductive `terms'?  This begs the question of what
is a `term', after all?
</p>
</div>
</div>
</div>

<div id="outline-container-orgf368918" class="outline-2">
<h2 id="orgf368918"><span class="section-number-2">8.</span> (Coinductive) Terms</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org773a20f" class="outline-3">
<h3 id="org773a20f"><span class="section-number-3">8.1.</span> Observations and interactions</h3>
<div class="outline-text-3" id="text-8-1">
<p>
We wish to associate a term with each vertex in a term graph
but we are grappling with the question of what is a term.
One way to answer to this question is to consider what we
can observe at the vertex and how we can `interact' with it.
The observation related to a vertex is simply its head.  A
`unit' interaction consists of supplying an index (between 1
and the arity of the vertex's head) to the vertex and
getting back another vertex (the child).
</p>

<p>
Notice that we can overload the equation  to mean the following:
</p>

<ol class="org-ol">
<li>An observation that the head of \(v\) is \(f\) and</li>

<li>\(n\) unit interactions with \(v\) that respectively yield
the vertices \(v_1, \ldots, v_n\).</li>
</ol>

<p>
is literally the relation \(v \eqn
f(v_1, \ldots, v_n)\). 
</p>
</div>
</div>

<div id="outline-container-orgbacb3cd" class="outline-3">
<h3 id="orgbacb3cd"><span class="section-number-3">8.2.</span> Position space</h3>
<div class="outline-text-3" id="text-8-2">
<p>
A <i>position space</i> is any set of index sequences \(P\) that
that is <i>prefix closed</i>: if \(q\in P\) then every prefix \(p\)
of \(q\) is also in \(P\)
</p>
</div>

<div id="outline-container-org654b43d" class="outline-4">
<h4 id="org654b43d"><span class="section-number-4">8.2.1.</span> Position space of a vertex in a term graph</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
The set of positions \(\id{pos}_G\ v\) of a vertex \(v\) in a term
graph \(G\) forms a position space.  (Exercise: verify this.)
</p>
</div>
</div>

<div id="outline-container-org390d543" class="outline-4">
<h4 id="org390d543"><span class="section-number-4">8.2.2.</span> Example of a position space</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
In Example <a href="#term-tree">6.2</a>, the position space \(\id{pos}(t_1)\)
associated with the vertex \(t_1\) is the set of positions
\(\set{[\ ], [1], [2], [1\ 2]}\).   
</p>
</div>
</div>
</div>

<div id="outline-container-org4bf3646" class="outline-3">
<h3 id="org4bf3646"><span class="section-number-3">8.3.</span> Behaviour</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-org6370a27" class="outline-4">
<h4 id="org6370a27"><span class="section-number-4">8.3.1.</span> Behaviour over a signature</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
A <i>behaviour</i> \(B\) <i>over</i> a signature \(\Sigma\) is a total
function from a position space (denoted \(\id{pos}_G\ B\)) to
\(\Sigma\) that is <i>upward closed</i>, i.e.,
</p>

<p>
If \(p \in \id{pos}_G\ B\) and \(B\ p \in \Sigma^{(n)}\), then
\(\forall\ i\in \N_1, i\in \N_1(n)\ \text{iff}\ pi \in
\id{pos}_G\ B\).  Here \(pi\) denotes the concatenation of the
position \(p\) with the index \(i\).
</p>
</div>
</div>

<div id="outline-container-orgf27bc18" class="outline-4">
<h4 id="orgf27bc18"><span class="section-number-4">8.3.2.</span> The concatenation of an index with a behaviour</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
If \(B\) is a behaviour over \(\Sigma\) and \(1\in\N_1\), then \(i\
B\) is the map defined as follows:
</p>

<p>
\[i\ B \ida \set{(ip \mapsto B\ p)\ |\  p\in \id{pos}_G\ B}\]
</p>

<p>
Exercise:  Is \(i\ B\) a position space?  Justify your answer?
</p>
</div>
</div>

<div id="outline-container-ex-behaviour" class="outline-4">
<h4 id="ex-behaviour"><span class="section-number-4">8.3.3.</span> Examples of behaviours</h4>
<div class="outline-text-4" id="text-ex-behaviour">
<p>
Assume \(\Sigma\) has constructors \({\sf f}, {\sf g}, {\sf a},
{\sf b}\) with arity 2, 1, 0, and 0 respectively.    Then,
The following maps are all behaviours:
</p>

\begin{align*}
B_1 &\ida \set{[\ ]\mapsto {\sf a}}\\
B_2 &\ida \set{[\ ]\mapsto {\sf b}}\\
B_3 &\ida {\sf g}_1\ B_1 \union \set{[\ ]\mapsto {\sf g}}\\
B_4 &\ida {\sf f}_1\ B_3 \union {\sf f}_2\ B_2 \union \set{[\ ]\mapsto {\sf f}}
\end{align*}
</div>
</div>
</div>

<div id="outline-container-org75e9b0b" class="outline-3">
<h3 id="org75e9b0b"><span class="section-number-3">8.4.</span> Composing Behaviours</h3>
<div class="outline-text-3" id="text-8-4">
<p>
If \(B_1\ldots B_n\) are behaviours and \(f\in \Sigma^{(n)}\),
then we write \(f(B_1\ldots, B_n)\) to denote the behaviour
\((\Union_{i=1}^n\ i\ B_i) \union \set{[\ ]\mapsto f}\).  
</p>
</div>

<div id="outline-container-ex-bhvr-comp" class="outline-4">
<h4 id="ex-bhvr-comp"><span class="section-number-4">8.4.1.</span> Example</h4>
<div class="outline-text-4" id="text-ex-bhvr-comp">
<p>
Using this notation, the behaviours of Example <a href="#ex-behaviour">8.3.3</a>
may be rewritten as compositions:
</p>
\begin{align*}
B_1 &\ida {\sf a}()\\
B_2 &\ida {\sf b}()\\
B_3 &\ida {\sf g}(B_1)\\
B_4 &\ida {\sf f}(B_3, B_2)
\end{align*}
</div>
</div>
</div>

<div id="outline-container-org5a01820" class="outline-3">
<h3 id="org5a01820"><span class="section-number-3">8.5.</span> Coinductive Terms as Behaviour</h3>
<div class="outline-text-3" id="text-8-5">
<p>
Now, we are ready to formally define a term:
</p>

<p>
<b>Defn [(Coinductive) Term]</b> Given a signature \(\Sigma\) a <i>term over</i>
\(\Sigma\) is a behaviour over \(\Sigma\).
</p>

<p>
Notice that in the definition of term, we have dispensed
with the notion of vertices or term graphs.  The notion of a
term exists independent of a term graph, but may be
<i>generated</i> via interactions with a vertex in a term graph.
</p>
</div>
</div>

<div id="outline-container-obs-bhvr-vtx" class="outline-3">
<h3 id="obs-bhvr-vtx"><span class="section-number-3">8.6.</span> Observable behaviour of a vertex in a term graph</h3>
<div class="outline-text-3" id="text-obs-bhvr-vtx">
<p>
One way of capturing the sum total of interactions and
observations at a vertex is to list (a) the set of all valid
interaction sequences (positions), and (b) and the
observation of the head of the destination vertex at the end
of each path.  We call this the <i>observable behaviour</i>, or
just <i>behaviour of</i> a vertex.  
</p>

<p>
Formally, let \(G\) be a term graph over a signature \(\Sigma\).
The observable behaviour of a vertex \(v\) in \(G\), written
\(\id{obs}_G\ v\), is a map from the position space
\(\id{pos}_G\ v\) to \(\Sigma\) and is defined as
</p>

<p>
\[\id{obs}_G\ v\ p \ida h(\id{dest}_G\ v\ p)\]
</p>

<p>
The following inductive definition is an alternative way to
define the observable behaviour function:
</p>

\begin{align*}
 \frac{}{\id{obs}\ v\ [\ ] = h(v)} & \qquad\qquad \text{REF}\\ \\
 \frac{\id{obs}\ v_i\ p = f}{\id{obs}\ v\ ip = f}\quad v\xto{i}{G}v_io & \qquad \text{TRANS}
\end{align*}

<p>
(Exercise: show that the two alternative definitions are
equivalent.)
</p>

<p>
\(\id{obs}_G\) is called the <i>observable behaviour map of</i>
term graph \(G\).  The range of \(\id{obs}_G\), denoted \({\cal
B}_G\) is called the set of <i>observable behaviours in</i>
\(G\).
</p>
</div>
</div>


<div id="outline-container-org0ca5a50" class="outline-3">
<h3 id="org0ca5a50"><span class="section-number-3">8.7.</span> Example illustrating observable behaviour</h3>
<div class="outline-text-3" id="text-8-7">
<p>
Let us revisit the term graph \(G\) of Example <a href="#term-tree">6.2</a>,
For the vertex \(t_1\), its position space is the set
\(\set{[\ ], [1], [2], [1\ 1]}\).  Its observable behaviour,
\(\id{obs}(t_1)\), is the map
</p>
\begin{align*}
[\ ] & \mapsto {\sf f}\\
[1]  & \mapsto {\sf g}\\
[2]  & \mapsto {\sf a}\\
[1\ 1]  & \mapsto {\sf a}
\end{align*}

<p>
The set of observable behaviours of \(G\) is the collection of
observable behaviours of each of its vertices.
</p>

\begin{align*}
{\cal B}_G &= \id{obs}(t_1) \union &= \set{[\ ] \mapsto {\sf f}, [1]\mapsto {\sf g}, [2]\mapsto {\sf a}, [1\ 1]\mapsto {\sf a}} \union\\
            &= \id{obs}(t_2) \union &= \set{[\ ] \mapsto {\sf g}, [1]\mapsto {\sf a}} \union\\
            &= \id{obs}(t_3) \union &= \set{[\ ] \mapsto {\sf a}}\union\\
            &= \id{obs}(t_4)        &= \set{[\ ] \mapsto {\sf a}}
\end{align*}
</div>
</div>

<div id="outline-container-solution-term-graph" class="outline-3">
<h3 id="solution-term-graph"><span class="section-number-3">8.8.</span> Solution of a term graph</h3>
<div class="outline-text-3" id="text-solution-term-graph">
<p>
A <i>solution</i> to a term graph is function \(\sigma\) that maps
each vertex \(v\) in \(G\) to a behaviour such that if 
\[v \eqn f(v_1\ldots, v_n)\]
</p>

<p>
then
</p>

<p>
\[\sigma\ v = f(\sigma\ v_1, \ldots, \sigma\ v_n)\]
</p>
</div>
</div>

<div id="outline-container-org29bfb60" class="outline-3">
<h3 id="org29bfb60"><span class="section-number-3">8.9.</span> Proposition (Solution Lemma)</h3>
<div class="outline-text-3" id="text-8-9">
<p>
If \(G\) is a term graph, then the observable behaviour map
\(\id{obs}_G\) is the unique solution of \(G\).
</p>
</div>

<div id="outline-container-org9904760" class="outline-4">
<h4 id="org9904760"><span class="section-number-4">8.9.1.</span> Proof</h4>
<div class="outline-text-4" id="text-8-9-1">
<p>
The proof is in two parts:
</p>
</div>

<div id="outline-container-orgd36bf08" class="outline-5">
<h5 id="orgd36bf08"><span class="section-number-5">8.9.1.1.</span> Existence</h5>
<div class="outline-text-5" id="text-8-9-1-1">
<p>
\(\id{obs}_G\) is a solution of \(G\). 
</p>
</div>

<ul class="org-ul">
<li><a id="org5d4e873"></a>Proof<br>
<div class="outline-text-6" id="text-org5d4e873">
<p>
We need to prove that 
\[\id{obs}_G\ v = f(\id{obs}_G\ v_1, \ldots, \id{obs}_G\ v_n)\]
</p>

<p>
for each vertex \(v\) in \(G\). 
</p>


<p>
Simplifying this, we arrive at the task of proving the
following identity:
</p>

<p>
\[B= \Union_{i=1}^n i B_i \union \set{[\ ]\mapsto f}\]
</p>

<p>
This reduces to proving, for each \(p\in \id{pos}_G\ v\), the
following:
</p>

<ol class="org-ol">
<li>\(\id{obs}\ v\ [\ ] = f\), and</li>

<li>\(\id{obs}\ v\ ip = \id{obs}\ v_i\ p\) for each
\(i:\N_1(n)\).</li>
</ol>

<p>
The first of the claims follows from REF rule and the second
from the TRANS rule in the definition of \(\id{obs}\). (See
Section <a href="#obs-bhvr-vtx">8.6</a>.)   Done.
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org728d84e" class="outline-5">
<h5 id="org728d84e"><span class="section-number-5">8.9.1.2.</span> Uniqueness</h5>
<div class="outline-text-5" id="text-8-9-1-2">
<p>
If \(\sigma\) is a solution of \(G\), then \(\sigma = \id{obs}_G\). 
</p>
</div>

<ul class="org-ul">
<li><a id="org0f1e586"></a>Proof<br>
<div class="outline-text-6" id="text-org0f1e586">
<p>
Since \(\sigma\) is a solution, for each equation \(v=f(v_1,
\ldots, v_n)\), 
</p>

<p>
\[\sigma\ v = f(\sigma\ v_1, \ldots, \sigma\ v_n)\]
</p>

<p>
We prove by induction on \(p\) that \(\sigma\ v\ p = \id{obs}\
v\ p\) for all vertices \(v\) in \(G\).
</p>

<dl class="org-dl">
<dt>1. Base case</dt><dd>By expanding the behaviour equation
above, \(\sigma\ v\ [\ ] = f\).  But
\(\id{obs}\ v\ [\ ]\) is also \(f\) by REF rule
of the \(\obs\) rule system. (See Section
<a href="#obs-bhvr-vtx">8.6</a> for the REF rule.)</dd>

<dt>2. Inductive case</dt><dd>Consider \(\sigma\ v\ ip\) where
\(i:\N_1(n)\).  From the behaviour equation above
\(\sigma\ v\ ip = \sigma\ v_i\ p\).  Also, \(\id{obs}\ v\
      ip = \id{obs}\ v_i\ p\) from the TRANS rule in the
definition of \(\id{obs}\). (See Section <a href="#obs-bhvr-vtx">8.6</a>
for the TRANS rule.)  By the induction hypothesis,
\(\id{sigma}\ v_i\ p = \id{obs}\ v_i\ p\).  The result
follows from this.</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9f34f11" class="outline-3">
<h3 id="org9f34f11"><span class="section-number-3">8.10.</span> Coinductive terms as denotations of vertices in a term graph</h3>
<div class="outline-text-3" id="text-8-10">
<p>
Given a vertex graph \(G\), each vertex of \(G\) may be mapped
to its `meaning': a coinductive term which is obtained via
the solution of the flat system of term equations.
</p>

<p>
Inductive terms are solution sets of term graphs that are
finite and cycle-free.  Inductive terms have finite position
spaces.  Graphs with finite term graphs (with or without
cycles) yield what are called <i>rational</i> terms.  A rational
term is a term with a finite number of unique subterms.
Infinite graphs, with or without cycles yield a collection
of <i>co-inductive</i> terms.  The containment relations is as
follows:  
</p>

<p>
\[\text{Inductive}\subseteq \text{Rational}\subseteq \text{Co-inductive}\]
</p>
</div>
</div>


<div id="outline-container-orga37ac8d" class="outline-3">
<h3 id="orga37ac8d"><span class="section-number-3">8.11.</span> Comparing inductive and coinductive terms over a signature</h3>
<div class="outline-text-3" id="text-8-11">
<p>
One might be tempted to think of coinductive terms as
`limits' of inductive terms.  If we try to do that, we run
into the following difficulty.  Consider a non-empty
signature \(\Sigma\) consisting only of a unary constructor
\({\sf g}\).  The set of inductive terms, viz., \(T_{\sf
ind}(\Sigma)\) is empty, while the set of coinductive terms
is not.  So, there are no inductive terms available to
approximate the coinductive term \(t={\sf g}(t)\).
</p>
</div>
</div>

<div id="outline-container-org37ad98c" class="outline-3">
<h3 id="org37ad98c"><span class="section-number-3">8.12.</span> Unique solution (from the theory of hypersets)</h3>
<div class="outline-text-3" id="text-8-12">
<p>
Seeing terms as functions from a position space to
constructors is only one way of interpreting terms.  Another
way, which we have been using so far inductive terms, is
continue to see terms as tuples.  To accommodate coinductive
terms as tuples we will need confront the possibility that
tuples &#x2014; and ultimately sets &#x2014; could be circular, i.e.,
they contain themselves.  There is a a variant of set theory
that entertains this possibility (the theory of
non-well-founded sets, or `hypersets').  This theory has its
own formulation of the Solution Lemma: every flat system of
equations has a unique solution, which maps vertices to
tuples.  We will not make a detour into non-well-founded set
theory.  Instead, we will rely on functional programming to
do model circular objects in yet another way.
</p>
</div>
</div>

<div id="outline-container-org968be1f" class="outline-3">
<h3 id="org968be1f"><span class="section-number-3">8.13.</span> More examples</h3>
<div class="outline-text-3" id="text-8-13">
</div>
<div id="outline-container-term-dag" class="outline-4">
<h4 id="term-dag"><span class="section-number-4">8.13.1.</span> Term DAG</h4>
<div class="outline-text-4" id="text-term-dag">
<p>
Consider the possibility of <i>sharing</i> vertices in a
term graph, so we have term graphs that are finite and
acyclic.  Here is an example:
</p>
<div class="multicol" id="org56bf972">
<div class="foo" id="org7599f13">
\begin{align*}
t_1 &\eqn {\sf f}(t_2, t_3)\\
t_2 &\eqn {\sf g}(t_3)\\
t_3 &\eqn {\sf a}
\end{align*}

</div>

<div class="foo" id="org23c2335">

<div id="orgc3492ed" class="figure">
<p><img src="./figs/dag.png" alt="dag.png" width="200px">
</p>
</div>

</div>

</div>
<p>
Again, a bottom up strategy allows us to construct a
solution as tuples:
</p>
\begin{align*}
t_1 &\mapsto {\sf f(g(a), a)}\\
t_2 &\mapsto {\sf g(a)}\\
t_3 &\mapsto {\sf a}\\
\end{align*}
<p>
In Racket, we would this as 
</p>
<div class="org-src-container">
<pre class="src src-racket" id="orga38a59e">(let* ([t3 (a)]
       [t2 (g t3)]     ; sharing t3
       [t1 (f t2 t3)]) ; sharing t3
  (check-equal? t1 '(f (g (a)) (a))))
</pre>
</div>

<p>
It is worth noting that while systems of equations in the
above example and Example <a href="#term-tree">6.2</a>, they both result in
the same sets of behaviours, i.e., terms.  For example, 
the behaviour \({B}(t_1)\) is identical to that of \(t_1\) in
Example <a href="#term-tree">6.2</a>.
</p>
</div>
</div>

<div id="outline-container-inf" class="outline-4">
<h4 id="inf"><span class="section-number-4">8.13.2.</span> Infinite Term Graph</h4>
<div class="outline-text-4" id="text-inf">
<p>
Consider an infinite graph
</p>
<div class="multicol" id="org92bb937">
<div class="foo" id="org0df0fb0">
\begin{align*}
t_1 &\eqn {\sf g}(t_2)\\
t_2 &\eqn {\sf g}(t_3)\\
t_3 &\eqn {\sf g}(t_4)\\
\vdots
\end{align*}

</div>

<div class="foo" id="org909b0d5">

<div id="org623c2d2" class="figure">
<p><img src="./figs/inf.png" alt="inf.png" width="50px">
</p>
</div>

</div>

</div>

<p>
Now it is no longer possible to write the `solution' of
\(t_1\) as a finite nested list.  Instead, we informally write
\(t_1\) to be the term \({\sf g}({\sf g}({\sf g}(\ \ldots )))\).
</p>

<p>
A more precise semantics of the term at \(t_1\) may be
obtained by constructing the behaviour \({B}(t_1)\):
</p>

\begin{align*}
[\ ] & \mapsto {\sf g}\\
[1] & \mapsto {\sf g}\\
[1\ 1] & \mapsto {\sf g}\\
\vdots
\end{align*}
<p>
Notice that this is also the behaviour of each of the
\(t_i\)'s.
</p>
</div>
</div>
<div id="outline-container-cyc" class="outline-4">
<h4 id="cyc"><span class="section-number-4">8.13.3.</span> Cyclic Term graph</h4>
<div class="outline-text-4" id="text-cyc">
<p>
Infinite (or coinductive) terms can be obtained as solutions
to a finite set of equations.  Consider the cyclic term
graph with one vertex:
</p>
<div class="multicol" id="orgf3cd6a1">
<div class="foo" id="org4f35048">
<p>

</p>

\begin{align*}
t_1 & \eqn {\sf g}(t_1)
\end{align*}

</div>

<div class="foo" id="org96444a4">

<div id="org9040255" class="figure">
<p><img src="./figs/cyc.png" alt="cyc.png" width="50px">
</p>
</div>

</div>

</div>

<p>
Because of the self-loop, the position space of \(t_1\) is
infinite: \([\ ], [1], [1\ 1], \ldots\) .  The position space
is \(1^*\).  Each position \(1^n\) is mapped to the constructor
\({\sf g}\).  This is identical to the behaviour at vertex
\(t_1\) Example <a href="#inf">8.13.2</a>. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0ddf1ec" class="outline-2">
<h2 id="org0ddf1ec"><span class="section-number-2">9.</span> Reasoning about Equality of Terms via Bisimulation</h2>
<div class="outline-text-2" id="text-9">
<p>
When are two terms the same?  Since we identify terms with
behaviour, the equality of terms is derived from equality of
behaviour.  Now, two behaviours are identical if they are
equal as functions: they share the same domain of definition
and they match for each position in that domain.  One
problem from a practical standpoint is that the domains of
the terms may be large or even infinite.  
</p>

<p>
Another approach is to consider the vertices in a term graph
whose solution maps the vertices to the terms we wish to
compare.  Now we are no longer looking at the terms
directly, but through the structural (head and edge)
relationships between vertices they represent in a term
graph.
</p>

<p>
We need to be careful in defining what we mean by `same'.
Sameness and distinction between objects depends on what we
are allowed to observe about the objects.  Thus equivalence
of objects is modulo `observation.'  In the case of terms,
the observations are constructor symbols and we are allowed
to examine the head of a term to identify the constructor.
Now, equal terms should not only have equal heads, but the
equality should also hold for the corresponding pairs of
subterms.  For example, consider the term equations
\(t_1 \eqn {\sf f}(t_2, t_3)\) and \(t'_1 \eqn {\sf f}(t'_2, t'_3)\).
Suppose we were to claim that \(t_1\) and \(t'_1\) denote the
same term.  We then need to show that this equality must
also `flow down' to the subterms: i.e, we should have
equality between \(t'_1\) and \(t'_1\) and also between \(t'_2\)
and \(t'_2\).  Let's call this inference rule `DOWN'.  We also
want equality to flow upwards.  So if the corresponding
subterms are equal, then clearly the terms constructed with
the same constructor and the corresponding subterms should
be equal.  Let's call this rule `UP.' 
</p>
</div>


<div id="outline-container-bicycle" class="outline-4">
<h4 id="bicycle"><span class="section-number-4">9.0.1.</span> Example of circular reasoning</h4>
<div class="outline-text-4" id="text-bicycle">
<p>
We need to be careful, for, otherwise we could be trapped in
a hopelessly circular argument:  Consider the term graph
with two vertices: 
</p>

\begin{align*}
t_1 & \eqn {\sf g}(t_2)\\ \\
t_2 & \eqn {\sf g}(t_1)
\end{align*}

<p>
We want to show that both the vertices \(t_1\) and \(t_2\) refer
to the same infinite term \({\sf g}({\sf g}(...))\).  Now, if
were to reason using the `DOWN' rule, we end up with
something like this: 
</p>

<blockquote>
<p>
\(t_1\) are \(t_2\) are the same, because
their heads are the same (both are \({\sf g}\)) and their
immediate subterms, viz \(t_2\) and \(t_1\) are the same.   
</p>
</blockquote>

<p>
This is clearly a circular argument.  The objects of our
reasoning may be circular, but circular reasoning is
mathematically unacceptable: A proof can not assume what it
is trying to prove.  Trying the `UP' rule instead doesn't
help either.  A different approach is needed, and this is
where the notion of bisimulation comes in.
</p>

<p>
The intuitive idea behind bisimulation is that we `decree'
that two terms are equal, and challenge anyone to show us
where we are wrong.  This kind of reasoning may seem
untenable, but it's not without value or use.  Imagine a
court scene in which a defendant charged with murder claims
that he was away with his friend in Mumbai on the night of a
crime that took place in Delhi.  His alibi provides an
argument consistent with the defendant's claim.  Should the
defendant be pronounced guilty?  In the absence of any
contradictory evidence challenging or repudiating the claims
of the defendant, a jury will be unable to prosecute the
defendant and the defendant will be acquitted.
</p>

<p>
Reasoning with bisimuation is similar: first we propose an
`equality' (bisimulation) relation.  Then, we try to verify
that this relation is consistent with the equality flowing
down between subterms.
</p>
</div>
</div>

<div id="outline-container-org5dd0c04" class="outline-3">
<h3 id="org5dd0c04"><span class="section-number-3">9.1.</span> Definition of Bisimulation</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Let \(T\) be a \(\Sigma\)-term graph with vertex set \(V\).   A
relation \(R\subseteq V\times V\) is a <i>bisimulation</i> if for
each pair \((v,v')\in R\), the following is true:
</p>

<ol class="org-ol">
<li>\(\id{hd}(v)=\id{hd}(v')\):   Their heads are the same, and</li>

<li>for each \(i\), \(1\leq i \leq \alpha(\id{hd}(v))\), if
\(v\xto{i}{}v_i\) and \(v'\xto{i}{}v'_i\), then \((v_i, v'_i)
    \in R\).</li>
</ol>

<p>
We say two vertices \(v\) and \(v'\) in the $&Sigma;$-term graph
are <i>bisimilar</i> iff there is a bisimulation relation \(R\)
such that \((v,v')\in R\).
</p>

<p>
Therefore, we work with bisimilarity as the notion of
observational equivalence between vertices.  One way of
thinking about this (and it will be generalised in later
classes) is that vertices are like `states': black boxes
that allow only specific observations about them and
interactions that take you to other vertices.  Vertices that
are bisimilar have the same observations.  In addition,
identical interactions with them take us to states that are
themselves bisimilar.
</p>
</div>
</div>

<div id="outline-container-org9bd6b41" class="outline-3">
<h3 id="org9bd6b41"><span class="section-number-3">9.2.</span> Examples</h3>
<div class="outline-text-3" id="text-9-2">
</div>
<div id="outline-container-ind_equal" class="outline-4">
<h4 id="ind_equal"><span class="section-number-4">9.2.1.</span> Reasoning about equality based on induction</h4>
<div class="outline-text-4" id="text-ind_equal">
<p>
Consider the terms in Examples <a href="#term-tree">6.2</a> and <a href="#term-dag">8.13.1</a>.  If we take a
larger term graph that include both of the individual term
graphs and rename the vertices in Example <a href="#term-dag">8.13.1</a> with primes,
then we want to show that vertices \(t_1\) and \(t'_1\) refer to
the same term.  Since both these term graphs are acyclic, we
can proceed by reasoning with induction.  We define equality
inductively via the judgement \(t \sim_{\sf ind} t'\).
</p>

\begin{align*}
\frac{t_1 \sim_{\sf ind} t'_1, \ldots t_n \sim_{\sf ind} t'_n}{t\sim_{\sf ind}t'}\quad t=f(t_1, \ldots, t_n)\ \text{and}\   t'=f(t'_1, \ldots, t'_n) \qquad \qquad UP
\end{align*}


<p>
<b>Exercise</b>: Using this rule, we prove that \(t_1 \sim_{\sf
ind} t_2\).
</p>

<p>
As mentioned earlier, this rule is useless in the presence
of circular or infinite term graphs; instead, we need
reasoning based on bisimulation.   
</p>
</div>
</div>

<div id="outline-container-bisim_equal" class="outline-4">
<h4 id="bisim_equal"><span class="section-number-4">9.2.2.</span> Reasoning about equality based on bisimulation, or co-induction</h4>
<div class="outline-text-4" id="text-bisim_equal">
<p>
Consider again the graphs in Examples <a href="#inf">8.13.2</a> and <a href="#cyc">8.13.3</a> (with
the vertex in Example <a href="#cyc">8.13.3</a> primed so as to be
distinguishable from those in Example <a href="#inf">8.13.2</a>.    We would like
to show that all the vertices in the two term graphs are
bisimilar to each other.  For this, we construct a
bisimulation relation 
</p>

<p>
\[R = \set{(t_i, t'_1)} \ |\ i\in \N_1\]
</p>

<p>
We claim \(R\) is a bisimulation.  To prove this, we pick an
arbitrary pair \((t_i, t'_1)\) from \(R\).  Clearly, \(t_i\) and
\(t'_1\) have the same head, viz., \({\sf g}\).  Now,
\(t_i\xto{1}{}t_{i+1}\) whereas \(t'_1\xto{1}{}t'_1\).  We need
to verify if the pair \((t_{i+1}, t'_1)\) is in \(R\).  It is,
because that's how we chose \(R\) in the first place!
Therefore, \(t_1\) and \(t'_1\) are bisimilar.  As you can see,
establishing bisimilarity hinges on guessing an appropriate
bisimulation relation and sometimes that could take some
effort.
</p>

<p>
Consider now the Example <a href="#bicycle">9.0.1</a>.  Here the bisimulation
\(R=\set{(t_1, t_2)}\) is sufficient to witness the
bisimilarity of \(t_1\) and \(t_2\).  
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org45805bf" class="outline-2">
<h2 id="org45805bf"><span class="section-number-2">10.</span> Replacement</h2>
<div class="outline-text-2" id="text-10">
<p>
In the model of computing that we are interested in this
course, computation proceeds by reducing term trees.  The
reduction operation relies on <i>replacement</i>: taking a term
tree, identifying a subtree and replacing that subtree with
another term tree.
</p>

<p>
We will try to understand replacement in the more general
setting of term graphs.
</p>
</div>


<div id="outline-container-org90abf7f" class="outline-3">
<h3 id="org90abf7f"><span class="section-number-3">10.1.</span> Replacement</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Let \(G\) be a term graph and let \(t\) be a term vertex and let
\(t_p\) be the subterm vertex of \(t\) at position \(p\).  Let \(s\)
be another term vertex.  If we think of \(t\) as the root of a
a (possibly infinite) tree, then the replacement of the
subterm of \(t\) at position \(p\) by term \(s\), denoted
\(\id{replace}(t,p,s)\) results in a new term graph.
Everything works out nicely when the terms are inductive or
infinite.  But, when dealing with circular term graphs,
`unrolling' the circular term graph is necessary when
performing replacement.
</p>

<p>
Here are some examples.  For replacement involving term
trees, we dispense with writing down elaborate term graphs
and rely on the tree (expression) notation:
</p>
\begin{align*}
\id{replace}({\sf f(g(a), b)}, [1\ 1], {\sf b}) = {\sf f(g(b), b)}\\ \\
\id{replace}({\sf f(g(a), b)}, [1], {\sf b}) = {\sf f(b, b)}\\ \\
\id{replace}({\sf f(g(a), b)}, [\ ], {\sf b}) = {\sf b}
\end{align*}


<p>
What happens when (sub)terms are shared?  Consider 
</p>
\begin{align*}
t_1 &\eqn {\sf f}(t_2, t_3)\\
t_2 &\eqn {\sf g}(t_3)\\
t_3 &\eqn {\sf a}\\
t_4 &\eqn {\sf b}
\end{align*}

<p>
What is the result of \(\id{replace}(t_1, [1\ 1], t_4)\)?  Is
it \({\sf f(g(b), a)}\) or \({\sf f(g(b), b)}\)?   The correct
answer is \({\sf f(g(b), a)}\) because we may think of position \([1\ 1]\)
as a pointer which is now pointing to \(t_4\).  The pointer
\([2]\) is unchanged.
</p>
</div>

<div id="outline-container-cycrep" class="outline-4">
<h4 id="cycrep"><span class="section-number-4">10.1.1.</span> Example: replacement involving cycles</h4>
<div class="outline-text-4" id="text-cycrep">
<p>
Now consider the following situation that involves cycles in
the term graph:
</p>
\begin{align*}
t_0 &= {\sf g}(t_0)
\end{align*}

<p>
Here, the term graph consists of a single vertex \(t_0\)
pointing to itself, denoting the infinite term \({\sf
g(g(g(\ldots)))}\).  Suppose we wish to replace in \(t_0\), the
subterm at position \([1\ 1]\) with the term \(s={\sf a}()\).
Then, we first need `unroll' \(t_0\) a sufficient number of
times before we can graft \(s\) at the right position. 
</p>
\begin{align*}
t_0 &={\sf g}(t_1)\\
t_1 &={\sf g}(t_2)\\
t_2 &={\sf a}()
\end{align*}
</div>
</div>
</div>

<div id="outline-container-org06824cf" class="outline-3">
<h3 id="org06824cf"><span class="section-number-3">10.2.</span> Defining subterm and replacement</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Let \(t\) be a term and let \(p\) be a position in \(t\).  Let \(t'\)
be a subterm of \(t\) at position \(p\).  This means that 
</p>

<ol class="org-ol">
<li>\(p\in \id{pos}_G(t)\).</li>

<li>If \(q\in \id{pos}_G(t')\), then \(pq\in \id{pos}_G(t)\) and
\(t(pq) = t'(q)\).</li>
</ol>

<p>
Let \(s\) be a term.  \(\id{replace}(t, p, s)\) results in the
following term \(r\):
</p>

\begin{align*}
\id{pos}_G(r) &= (\id{pos}_G(t) \setminus \set{a\in\id{pos}_G(t) |\ \id{prefix}(a)=p}) \\
            &\union \set{p}\id{pos}_G(t')
\end{align*}

<p>
We define \(r\) via pattern matching positions:
</p>
\begin{align*}
r (pq) &= s(q) & \text{for each}\  pq\in \id{pos}_G(r)\\
r (q)  &= t(q) & \text{if $p$ is not a prefix of $q$}\\
\end{align*}

<p>
Exercise:  Verify that the result of a replacement is indeed
a term. 
</p>
</div>

<div id="outline-container-org121e226" class="outline-4">
<h4 id="org121e226"><span class="section-number-4">10.2.1.</span> Example</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
Consider again Example <a href="#cycrep">10.1.1</a>.  The term graph \(t_1={\sf
g}(t_1)\) yields the following term: \(\set{(1^n\mapsto {\sf
g})\ |\ n\in \N}\).  The term \({\sf a}()\) corresponds to the
term \(\set{[\ ]\mapsto {\sf a}}\).  Replacing the subterm at
position \([1\ 1]\) in \(t_1\) with with \({\sf a}()\) yields the
term \(r\).  The position space of is \(\set{[\ ], [1], [1\
1]}\).
</p>

\begin{align*}
r\ [\ ] &= {\sf g}\\
r\ [1]  &= {\sf g}\\
r\ [1\ 1] &={\sf a}
\end{align*}
</div>
</div>
</div>
</div>

<div id="outline-container-org72756f5" class="outline-2">
<h2 id="org72756f5"><span class="section-number-2">11.</span> Implementing term graphs and replacement in Racket</h2>
<div class="outline-text-2" id="text-11">
<p>
The following Racket implmentation tries to capture the idea
of co-inductive terms and replacement.  We do not explicitly
need to construct a representation of behaviour functions or
term graphs.  These happen behind the scenes in the
implementation.  The racket implementation provides a
`user-interface' to build inductive and co-inductive terms. 
</p>
</div>

<div id="outline-container-orgf029b7f" class="outline-3">
<h3 id="orgf029b7f"><span class="section-number-3">11.1.</span> Inductive term</h3>
<div class="outline-text-3" id="text-11-1">
<p>
We define inductive terms as lists whose first element is a
symbol.  For simplicity we will altogether avoid arity
checking.  Every time we call <code>list</code> a brand new vertex is
created in the term graph.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="orge12431d">(check-true (term? (list 'a)))
(check-true (term? (list 'g '(a))))
(check-true (term? '(f (g (a)) (a))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4224dac" class="outline-3">
<h3 id="org4224dac"><span class="section-number-3">11.2.</span> Coinductive terms</h3>
<div class="outline-text-3" id="text-11-2">
<p>
To define co-inductive terms, we need a coinductive version
of <code>list</code>: <code>colist</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="org37a0f30">(check-true (term? (list 'g '(a))))
(check-true (term? (colist 'g '(a))))
(check-true (term? (rec t (colist 'g t))))
(check-true (term? (list 'g (rec t (colist 'g t)))))
</pre>
</div>

<p>
<code>colist</code> is defined by extending Racket's syntax.  <code>colist</code>
is a lazy constructor.  It does not evaluate its arguments,
and thereby allows delaying their evaluation.  This is a
crucial tool to construct co-inductive terms.  We have
already seen a cousin <code>scons</code> of <code>colist</code> which was used to
construct streams.
</p>
<div class="org-src-container">
<pre class="src src-racket" id="org9c07289">(define-syntax colist
  (syntax-rules ()
    [(colist sym terms ...) 
     (lambda () (list sym terms ...))]))
</pre>
</div>

<p>
A term is either one built inductively (using <code>list</code>) or
built coinductively (using <code>colist</code>):
</p>
<div class="org-src-container">
<pre class="src src-racket" id="org392af92">;;; term? :: any/c -&gt; boolean?
(define term? (or/c procedure? list?))
</pre>
</div>

<p>
The head of a term returns the constructor:
</p>
<pre class="example" id="org7f62f15">
(check-equal? (hd (g (a))) 'g)
(check-equal? (hd (rec t (colist 'g t))) 'g)
</pre>

<p>
If the term is a list, that's easy: the head is just the
<code>car</code> of the list.  If the term is built using <code>colist</code>,
then we will need to first <i>unroll</i> the procedure representing the
term to get a list.   <i>Then</i> we take the car of that list.
</p>
<div class="org-src-container">
<pre class="src src-racket" id="orgf4ca100">;;; unroll :: term? -&gt; term?
(define (unroll t)
  (if (procedure? t) (t) t))

;;; hd :: term? -&gt; symbol?
(define (hd t)
  (car (unroll t)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge81511b" class="outline-3">
<h3 id="orge81511b"><span class="section-number-3">11.3.</span> Index</h3>
<div class="outline-text-3" id="text-11-3">
<p>
An index is a positive integer.  
</p>
<div class="org-src-container">
<pre class="src src-racket" id="org716cabd">;;; posint? :: any/c -&gt; boolean?
(define posint? (and/c integer? (&gt;=/c 1)))
(define index? posint?)
</pre>
</div>
</div>
</div>
<div id="outline-container-org40eda0f" class="outline-3">
<h3 id="org40eda0f"><span class="section-number-3">11.4.</span> Term reference</h3>
<div class="outline-text-3" id="text-11-4">
<p>
Now that we have the head, let's try to locate the children
of a term.  Analogous to Racket's <code>list-ref</code>, we define
<code>term-ref</code> ,which returns the <code>i=th element of the (list
representing) the term.  =term-ref</code> indexes into a term and
returns the immediate subterm at that index.  If the index
is greater than the arity of the term's head, Racket throws
an error.
</p>
<div class="org-src-container">
<pre class="src src-racket" id="org7cbc2ac">;;; term-ref :: term? posint? -&gt; term?
(define (term-ref t i)
  (list-ref (unroll t) i))

(check-equal? (term-ref (list 'f '(a) '(b)) 1) '(a))
(check-equal? (term-ref (list 'f '(a) '(b)) 2) '(b))
(check-exn exn:fail? (lambda () (term-ref (list 'f (a) '(b)) 3))) ; index type checking 
</pre>
</div>
</div>
</div>


<div id="outline-container-org5dcd764" class="outline-3">
<h3 id="org5dcd764"><span class="section-number-3">11.5.</span> Position</h3>
<div class="outline-text-3" id="text-11-5">
<p>
A position is a sequence of indices.
</p>
<div class="org-src-container">
<pre class="src src-racket" id="orgda4f78d">;;; pos? :: any/c -&gt; boolean?
(define pos? (listof index?))
(check-true (pos? '()))
(check-true (pos? '(1 3 2)))
(check-false (pos? '(0 1)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a7453f" class="outline-3">
<h3 id="org4a7453f"><span class="section-number-3">11.6.</span> Subterm</h3>
<div class="outline-text-3" id="text-11-6">
<p>
Given  a position <code>pos</code> in a term <code>t</code> we want to find the subterm at
that position.  
</p>

<div class="org-src-container">
<pre class="src src-racket" id="org864a1f3">(check-equal? (subterm '(f (a) (a)) '())
              '(f (a) (a)))

(check-equal?  (subterm '(f (a) (b)) '(2))
              '(b))

(letrec ([t (colist 'g t)])
  (check-equal?  (subterm  t '(1 1))
                 t))


(letrec ([t (colist 'f t '(a))])
  (check-equal? (subterm t '(1 1 2))
                '(a))
  (check-equal? (subterm t '(1 1 1))
                t))

</pre>
</div>

<p>
If the position is empty, then the answer is
<code>t</code>. Otherwise, we take the first index from <code>pos</code>, say <code>i</code>,
and search inside the <code>i=th</code>  child <code>t_i</code> of <code>t</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="orgffcd0de">;;; subterm :: term? pos? -&gt; term?
(define (subterm t pos)
  (letrec ([loop (lambda (t pos)
                   (cond [(null? pos) t]
                         [else (let* ([i (first pos)]
                                      [t_i (term-ref t (first pos))])
                                 (loop t_i (rest pos)))]))])
    (loop t pos)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org52a9ae5" class="outline-3">
<h3 id="org52a9ae5"><span class="section-number-3">11.7.</span> Replacement in a flat list</h3>
<div class="outline-text-3" id="text-11-7">
<p>
Before defining replacement in terms, we consider a simpler
situation: replacing an element at a particular index in a
list with another element.  We call this operation
<code>replace-flat</code>.  <code>(replace-flat ls i val)</code> takes a list
<code>ls</code>, an index <code>i</code> within the boundaries of <code>ls</code> and a value
<code>val</code> and return a new list whose value at position <code>i</code> is
<code>val</code>, but all other positions, it is the same as that of
<code>ls</code>.
</p>


<div class="org-src-container">
<pre class="src src-racket" id="orgd649010">(check-equal? (replace-flat '(f a b) 1 'c) '(f c b))
(check-exn exn:fail? (lambda ()  (replace-flat '(f a b) 0 'c)))
</pre>
</div>
</div>


<div id="outline-container-orgc9df3cc" class="outline-4">
<h4 id="orgc9df3cc"><span class="section-number-4">11.7.1.</span> <code>replace-flat</code> definition</h4>
<div class="outline-text-4" id="text-11-7-1">
<p>
<code>replace-flat</code> checks if <code>i</code> is a sane value.  If so, it
calls <code>replace-flat-helper</code>, otherwise it raises an error.
</p>

<p>
<code>replace-flat-helper</code> is a simple exercise in list
recursion. 
</p>
<div class="org-src-container">
<pre class="src src-racket" id="orga329174">;;; replace-flat :: list? index? any/c -&gt; list?
(define (replace-flat ls i val)
  (if (and (posint? i)
           (&lt;= i (length ls)))
      (replace-flat-helper ls i val)
      (error 'replace-flat "incompatible args: ls: ~a, i:~a" ls i)))

(define (replace-flat-helper ls i val)
  (letrec ([f (lambda (l j)
                (cond [(zero? j) (cons val (cdr l))]
                      [else (cons (car l)
                                  (f (cdr l) (sub1 j)))]))])
    (f ls i)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga9c445b" class="outline-3">
<h3 id="orga9c445b"><span class="section-number-3">11.8.</span> Replace</h3>
<div class="outline-text-3" id="text-11-8">
<p>
Now we come to <code>replace</code>.
In the first test below, the subterm <code>(a)</code> in the term <code>(g
(a))</code> occurs at position <code>[1]</code> and is replaced <code>(b)</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="orge8bbe76">(check-equal?  (replace '(g (a)) '[1] '(b))
               ;; replace '(a) with '(b)
               '(g (b)))
</pre>
</div>

<p>
In the test below, the subterm <code>(a)</code> occurs at position <code>[1
1]</code> in the top level expression and is again replaced by
<code>(b)</code>.
</p>

<div class="org-src-container">
<pre class="src src-racket" id="orge204260">(check-equal?  (replace '(f (g (a)) (b)) '[1 1] '(b))
               ;; replace (a) with (b)
               '(f (g (b)) (b)))

</pre>
</div>

<p>
In the test below, a coterm <code>t</code> is constructed as shown
below in  Figure <a href="#orga4534d4">1</a> on the .  We wish to
replace the subterm at position <code>[1 1 2]</code> in <code>t</code> with
<code>(b)</code>.   That involves unrolling <code>t</code> a few times before
<code>(b)</code> can be grafted at the position <code>[1 1 2]</code>.  The result
is shown in Figure <a href="#orgaa148ce">2</a>.  
</p>


<div class="multicol" id="orgf8aa61f">
<div class="foo" id="orgfd9e967">

<div id="orga4534d4" class="figure">
<p><img src="./figs/replace-before.png" alt="replace-before.png" width="100px">
</p>
<p><span class="figure-number">Figure 1: </span>Term <code>t</code> (root)</p>
</div>

</div>

<div class="foo" id="org6238158">

<div id="orgaa148ce" class="figure">
<p><img src="./figs/replace-after.png" alt="replace-after.png" width="300px">
</p>
<p><span class="figure-number">Figure 2: </span>Replacing <code>t</code>'s subterm at <code>[1 1 2]</code> with <code>'(b)</code></p>
</div>

</div>

</div>


<div class="org-src-container">
<pre class="src src-racket" id="org0bf4010">(letrec ([t (colist 'f t '(a))])
  (let ([r (replace t '[1 1 2] '(b))])
    (check-equal?  (subterm r '[1 1 2]) '(b))
    (check-eq? (subterm r '[1 1 1]) t))) ; this last test should get you thinking!
</pre>
</div>

<p>
Exercise:  Write systems of flat equations that precisely
mimic the term graphs according to the Racket
implementation.  Then, draw diagrams of other possible term graphs
that represent the replacement.
</p>
</div>

<div id="outline-container-orgc0f4781" class="outline-4">
<h4 id="orgc0f4781"><span class="section-number-4">11.8.1.</span> Implementing <code>replace</code></h4>
<div class="outline-text-4" id="text-11-8-1">
<p>
<code>replace</code> takes a term <code>t</code>, a position <code>pos</code> and a <code>graft</code>
term.  
</p>

<ol class="org-ol">
<li>If the position is null, we return the graft.</li>

<li>Otherwise, we locate the immediate subterm of <code>t</code> at
<code>(car pos)</code>, say <code>ti</code>.  We  replace <code>ti</code> with the <code>graft</code> at
position <code>(cdr pos)</code>.  Let the result be <code>s</code>.</li>

<li>Finally, we <code>replace-flat</code> <code>t</code> with <code>s</code> at position
<code>(car pos)</code>.</li>
</ol>

<div class="org-src-container">
<pre class="src src-racket" id="org3081441">;;; replace: term? pos? term? -&gt; term?
(define (replace t pos graft)
  (let ([t (unroll t)])
    (cond [(null? pos) graft]
          [else (let* ([ti (term-ref t (car pos))]
                       [s (replace ti (cdr pos) graft)])
                  (replace-flat t (car pos) s))])))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org9bad3b9" class="outline-3">
<h3 id="org9bad3b9"><span class="section-number-3">11.9.</span> Boilerplate</h3>
<div class="outline-text-3" id="text-11-9">
<div class="org-src-container">
<pre class="src src-racket" id="org4b6c056">#lang racket
(require racket/contract)
(require racket/list)
(require rackunit)
(require mzlib/etc)
(provide (all-defined-out))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9f56221" class="outline-2">
<h2 id="org9f56221"><span class="section-number-2">12.</span> Implementing Bisimulation for Rational terms</h2>
<div class="outline-text-2" id="text-12">
<p>
In the Racket test cases below, each test below correctly describes
the bisimilarity of the given terms.
</p>

<p>
Exercise:  Convince yourself that these test cases make sense.
</p>
</div>
<div id="outline-container-org491c0f7" class="outline-3">
<h3 id="org491c0f7"><span class="section-number-3">12.1.</span> Test cases</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">
<pre class="src src-racket" id="org3a68d7f">(let ([t (a)])
  (check-true (bisimilar? t t)))

(let ([t1 (colist 'a)]
      [t2 (list 'a)])
  (check-true (bisimilar? t1 t2)))

(letrec ([t (colist 'g t)])
  (check-true (bisimilar? t t)))

(let* ([t1 (a)]
       [t2 (a)])
  (check-true (bisimilar? (list 'f t1 t2) (list 'f t1 t1))))

(letrec ([t1 (colist 'g t2)]
         [t2 (colist 'g t1)])
  (check-true (bisimilar? t1 t2)))


(letrec ([t1 (colist 'g t2)]
         [t2 (colist 'g t2)])
  (check-true (bisimilar? t1 t2)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org225c2a8" class="outline-3">
<h3 id="org225c2a8"><span class="section-number-3">12.2.</span> Implementation</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Exercise: Implement the function <code>bisimilar?</code>.  
</p>
</div>
</div>
</div>

<div id="outline-container-org1c3c282" class="outline-2">
<h2 id="org1c3c282"><span class="section-number-2">13.</span> References</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-orgc4584e4" class="outline-3">
<h3 id="orgc4584e4"><span class="section-number-3">13.1.</span> Induction</h3>
<div class="outline-text-3" id="text-13-1">
<dl class="org-dl">
<dt>Ana Bove 2018</dt><dd><a href="http://www.cse.chalmers.se/edu/year/2018/course/TMV027/induction.pdf">Notes on Inductive Sets and Induction</a>.</dd>
</dl>
</div>
</div>


<div id="outline-container-org0777d68" class="outline-3">
<h3 id="org0777d68"><span class="section-number-3">13.2.</span> Coinduction</h3>
<div class="outline-text-3" id="text-13-2">
<dl class="org-dl">
<dt>Kozen and Silva, 2016.  <b>Practical Coinduction</b></dt><dd>Math. Structures in Computer Science. pp 1&#x2013;21.
<a href="https://doi.org/10.1017/S0960129515000493">https://doi.org/10.1017/S0960129515000493</a>.</dd>

<dt><a href="https://www.researchgate.net/profile/Patrick_Bahr/publication/237062508_Infinitary_Term_Graph_Rewriting_is_Simple_Sound_and_Complete/links/00b4951b19ffad5de7000000/Infinitary-Term-Graph-Rewriting-is-Simple-Sound-and-Complete.pdf">Bahr 2012</a></dt><dd>Infinitary Term Graph Rewriting is Simple
Sound and Complete.  Rewriting Techniques and
Applications.  2012</dd>

<dt><a href="https://arxiv.org/pdf/1706.00677.pdf">Coinductive Foundations of Infinitary Rewriting and   Infinitary Equational Logic</a></dt><dd>Endrullis et al.  Logical
Methods in Computer Science.  Vol 14(1:3) 2018
pp. 1&#x2013;44.  <a href="http://www.lmcs-online.org">http://www.lmcs-online.org</a></dd>
</dl>
</div>
</div>



<div id="outline-container-org0a69273" class="outline-3">
<h3 id="org0a69273"><span class="section-number-3">13.3.</span> Knaster Tarski Theorem</h3>
<div class="outline-text-3" id="text-13-3">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Knaster-Tarski_theorem">Wikipedia page</a> on <b>Knaster-Tarski Theorem</b></li>

<li id="Jayadev Misra, 2014.  <b>Knaster-Tarski Theorem</b>"><a href="http://www.cs.utexas.edu/users/misra/Notes.dir/KnasterTarski.pdf">Online
Notes</a>.</li>

<li><a href="https://www.cs.cornell.edu/courses/cs6110/2017sp/lectures/lec07.pdf">Cornell CS 6110 S 17 Lec 7 Notes</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgac1c582" class="outline-3">
<h3 id="orgac1c582"><span class="section-number-3">13.4.</span> Solution Lemma and non-well-founded set theory</h3>
<div class="outline-text-3" id="text-13-4">
<dl class="org-dl">
<dt>Moss, Lawrence S. 2018</dt><dd>Non-wellfounded Set Theory, <a href="https://plato.stanford.edu/archives/sum2018/entries/nonwellfounded-set-theory">The
Stanford Encyclopedia of Philosophy (Summer 2018
Edition)</a>, Edward N. Zalta (ed.),</dd>
</dl>

<dl class="org-dl">
<dt>Akman and Pakkan, 1996</dt><dd><a href="file:///https:/www.ime.usp.br/~jstern/miscellanea/seminars/codata/Akman96.pdf">Nonstandard set theories and
information management</a>.  A readable discussion of Set
Theory with the Anti-foundation axiom and its
application to relational database theory (Sec 3.2).</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Venkatesh Choppella</p>
<p class="date">Created: 2024-08-15 Thu 16:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
