<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-08-15 Thu 16:56 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>v2-state: Basic Evaluator with state</title>
<meta name="author" content="noteness" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">v2-state: Basic Evaluator with state</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgcdac73e">1. Introduction</a></li>
<li><a href="#org52ef7cc">2. Stateful computation</a></li>
<li><a href="#org8d70748">3. Evaluation as a higher-order transformation and currying</a></li>
<li><a href="#org422edb7">4. Evaluator</a></li>
<li><a href="#org731237d">5. Unit Tests</a></li>
<li><a href="#orgfe829aa">6. Summary</a></li>
<li><a href="#org3177a49">7. Source code</a></li>
<li><a href="#org0562703">8. Next</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcdac73e" class="outline-2">
<h2 id="orgcdac73e"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In the new variant of the basic evaluator, a computation
consists of a value and a count of the number of
divisions.  
</p>

<p>
Again, the term structure of the language is the same:
</p>

<div class="org-src-container">
<pre class="src src-scheme">#lang racket
(provide (all-defined-out))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">(require eopl/eopl)
(define-datatype term term?
  [con (int integer?)]
  [div (num term?) (den term?)])
</pre>
</div>
</div>
</div>

<div id="outline-container-org52ef7cc" class="outline-2">
<h2 id="org52ef7cc"><span class="section-number-2">2.</span> Stateful computation</h2>
<div class="outline-text-2" id="text-2">
<p>
We define a new data type to represent <i>stateful
computations</i>.  The previous interpreters we did in class
had the following signature: they took terms <i>and</i> states
(or stores, as we called them there) and returned tuples
consisting of values and states.
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; eval-term : [term? state?] -&gt; [value? state?]
</pre>
</div>

<p>
We move a step closer towards an abstract understanding of
what the interpreter does by moving the state from the input
side to the output side.  How do we achieve this?  Through
currying.  In other words, we <i>define</i> a computation to be a
function that takes a state and returns a pair consisting of
a value and a state.  An interpreter maps terms to
computations as before.
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; type state? = nat? 
;;; type computation? = state? -&gt; [value? state?]
;;; eval-term : term? -&gt; computation? 
</pre>
</div>

<p>
Note that the Haskell definition in Wadler's paper for
computation is written as the type <code>M a</code> parameterized on
the type <code>a</code>.    
</p>

<div class="org-src-container">
<pre class="src src-haskell">data M a = State -&gt; (a, State)
</pre>
</div>

<p>
To keep things simple, we shall leave the parametrization
out when we define the basic types for the semantic entities
and computation in Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; Semantic Domains
(define nat?
  (and/c integer? (&gt;=/c 0)))
(define state? nat?)
(define value? integer?)
(define  computation? (state? . -&gt; . (list/c value? state?)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org8d70748" class="outline-2">
<h2 id="org8d70748"><span class="section-number-2">3.</span> Evaluation as a higher-order transformation and currying</h2>
<div class="outline-text-2" id="text-3">
<p>
We say a computation is a <i>state transformer</i>.  The
evaluator is a higher-order function that takes a term and
returns a computation which, given a state, returns a value
and a state.  Thus, given a term <code>t</code> and a state <code>s</code>, the
evaluator <code>eval-term</code> is invoked as
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; ((eval-term t) s)
</pre>
</div>

<p>
The double nesting of left parenthesis hurts the eye, so we
define a special function that does  currying for us:
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; : : [['a -&gt; ['b -&gt; 'c]] 'a 'b] -&gt; 'c
(define :
  (lambda (f v1 v2)
    ((f v1) v2)))
</pre>
</div>

<p>
Here, we use the quoted symbols ('a, 'b, 'c) to denote type
parameters.  The curry operator takes three arguments, the
first of which is a function of type 'a -&gt; ['b -&gt; 'c], and
two other arguments of type 'a and 'b, respectively.  It
returns argument of type 'c by applying the first argument
to the second, and applying the resultant function to the
third argument.
</p>

<p>
The curried  application of <code>eval-term</code>  to arguments <code>t</code>
and <code>s</code> now looks like:
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; (: eval-term t s)
</pre>
</div>
</div>
</div>


<div id="outline-container-org422edb7" class="outline-2">
<h2 id="org422edb7"><span class="section-number-2">4.</span> Evaluator</h2>
<div class="outline-text-2" id="text-4">
<p>
Here is the evaluator.  Each sub-computation (recursive call
to <code>eval-term</code>) returns a list of two elements, a value and
a new state.
</p>

<div class="org-src-container">
<pre class="src src-scheme">;;; eval-term : term? -&gt; computation?
(define eval-term
  (lambda (t)
    (lambda (s)
      (cases term t
        [con (int) (list int s)]
        [div (num den)
          (match-let ([(list n s1) (: eval-term num s)])
            (match-let ([(list d s2) (: eval-term den s1)])
              (list (quotient n d) (+ s2 1))))]))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org731237d" class="outline-2">
<h2 id="org731237d"><span class="section-number-2">5.</span> Unit Tests</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-scheme">;;; Testing

;;; Racket's unit testing framework
(require rackunit)

(check-equal? 
  (: eval-term (con 5) 0)   ;;; initial state is 0
  (list 5 0)   ;;; 
  ": eval-term 5 0 test")

(check-equal? 
  (: eval-term (div (con 5) (con 3)) 0) 
  (list 1 1) 
  ": eval-term  (div 5 3) 0 test")

(check-equal? 
  (: eval-term (div (con 7) (div (con 5) (con 3))) 0) 
  (list 7 2) 
  ": eval-term  (div 7 (div 5 3)) 0 test")
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe829aa" class="outline-2">
<h2 id="orgfe829aa"><span class="section-number-2">6.</span> Summary</h2>
<div class="outline-text-2" id="text-6">
<p>
A computation is now a function that maps a state to a tuple
consisting of a value and a state.  The interpreter maps
terms to computations.
</p>
</div>
</div>

<div id="outline-container-org3177a49" class="outline-2">
<h2 id="org3177a49"><span class="section-number-2">7.</span> Source code</h2>
<div class="outline-text-2" id="text-7">
<p>
<a href="v2-state.rkt">v2-state.rkt</a>
</p>
</div>
</div>

<div id="outline-container-org0562703" class="outline-2">
<h2 id="org0562703"><span class="section-number-2">8.</span> Next</h2>
<div class="outline-text-2" id="text-8">
<p>
From here, you can go to either of the following
interpreters:
</p>

<dl class="org-dl">
<dt><a href="../v3-output/index.html">v3-output</a></dt><dd>Another extension of the basic interpreter
that outputs a trace of the evaluation.</dd>

<dt><a href="../m2-state/index.html">m2-state</a></dt><dd>A monadic version of this
evaluator.</dd>
</dl>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: noteness</p>
<p class="date">Created: 2024-08-15 Thu 16:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
