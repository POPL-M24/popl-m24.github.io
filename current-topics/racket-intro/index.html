<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-08-16 Fri 00:03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Short introduction to Racket: Syntax and a simple Evaluation Model</title>
<meta name="author" content="Venkatesh Choppella" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../themes/readtheorg/style/css/extra.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../../themes/readtheorg/style/js/readtheorg.js"></script>
<script src="../../themes/math/style/js/math.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" type="text/css" href="../../themes/math/style/css/math.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<link rel="icon" type="image/png" href="../../themes/popl/style/img/favicon/popl.png" />
<div style="display: none"> \(
% Latex Preamble definitions here (mostly usepackage)
\usepackage%
%[dvipsnames]
{xcolor}
% make sure this is before the loading font packages
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage
%[dvipsnames]
{graphicx}
\usepackage{float}
%\usepackage[numbers]{natbib}
\usepackage[document]{ragged2e}
%
% enumitem doesn't seem to work with beamer
%\usepackage[inline]{enumitem}
\usepackage{wrapfig}
\usepackage{stackrel}
% extensible arrows
\usepackage{extpfeil}
% \usepackage{trfrac}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{automata, positioning, arrows, shapes.geometric}
\usepackage{turnstile}
\usepackage{comment}
%https://tex.stackexchange.com/questions/21334/is-there-a-package-that-has-the-clockwise-gapped-circle-arrow-in-it
% \usepackage{mathbx}
\usepackage{datetime}
\usepackage{datetime2}

%% Also See
%% http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% for general tips
\usepackage{listings}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{amsfonts} %% - also included by amssymb
\usepackage{mathpazo} %% - because the OP uses mathpazo, optional
%\usepackage{tufte-latex}
\usepackage{comment}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{hyperref}
%\usepackage{cleveref}
\)</div>
<div style="display: none"> \(
%% Your math definitions here
% \newcommand{\alphaequiv}{{\underset{\raise 0.7em\alpha}{=}}}
\newcommand{\yields}{\Rightarrow}
\newcommand{\derives}{\overset{*}{\yields}}
\newcommand{\alphaequiv}{=_{\alpha}}
\newcommand{\tto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\transitsto}[2]{{\overset{#1}{\underset{#2}{\longrightarrow}}}}
\newcommand{\xtransitsto}[2]{{\underset{#2}{\xrightarrow{#1}}}}
\newcommand{\xtransitsfrom}[2]{{\underset{#2}{\xleftarrow{#1}}}}
\newcommand{\xto}[2]{{\xtransitsto{#1}{#2}}}
\newcommand{\xfrom}[2]{{\xtransitsfrom{#1}{#2}}}
\newcommand{\xreaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
\newcommand{\reaches}[2]{{\underset{#2}{\xtwoheadrightarrow{#1}}}}
%\newcommand{\reaches}[2]{{\overset{#1}{\underset{#2}{\twoheadrightarrow}}}}
%\newcommand{\goesto}[2]{\transitsto{#1}{#2}}
%\newcommand{\betareducesto}{{\underset{\beta}{\rightarrow}}}
\newcommand{\betareducesto}{\rightarrow_{\beta}}
%\newcommand{\etareducesto}{{\underset{\eta}{\rightarrow}}}
\newcommand{\etareducesto}{\rightarrow_{\eta}}
%\newcommand{\betaetareducesto}{{\underset{\beta\ \eta}{\rightarrow}}}
\newcommand{\betaetareducesto}{\rightarrow_{\beta\eta}}
\newcommand{\preducesto}{\rhd}
\newcommand{\psimplifiesto}{\stackrel{\scriptstyle{*}}{\rhd}}
\newcommand{\lreducesto}{\rightsquigarrow}
\newcommand{\lsimplifiesto}{\stackrel{\scriptstyle{*}}{\lreducesto}}
\newcommand{\rewritesto}{\hookrightarrow}
\newcommand{\goesto}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\xgoesto}[1]{\xrightarrow{#1}}
\newcommand{\reducesto}{\stackrel{}{\rightarrow}}
\newcommand{\simplifiesto}{\stackrel{\scriptstyle{*}}{\rightarrow}}
\newcommand{\connected}[1]{\stackrel{#1}{\leftrightarrow}}
\newcommand{\joins}{\downarrow}
\newcommand{\evaluatesto}{\Longrightarrow}
%\newcommand{\lit}[1]{\hbox{\sf{#1}}}
\newcommand{\lit}[1]{{\sf{#1}}}
\newcommand{\true}{\lit{true}}
\newcommand{\false}{\lit{false}}
\def\Z{\mbox{${\mathbb Z}$}}
\def\N{\mbox{${\mathbb N}$}}
\def\P{\mbox{${\mathbb P}$}}
\def\R{\mbox{${\mathbb R}$}}
\def\T{\mbox{${\mathbb T}$}}
\newcommand{\Rp}{{\mathbb{R}}^+}
\def\Bool{\mbox{${\mathbb B}$}}
\def\Q{\mbox{${\mathbb Q}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sL{\mbox{${\cal L}$}}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\sR{\mbox{${\cal R}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sO{\mbox{${\cal O}$}}
\def\sT{\mbox{${\cal T}$}}
\def\sU{\mbox{${\cal U}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\osum{${{\bigcirc}}\!\!\!\!{\rm s}~$}
\def\pf{\noindent {\bf Proof}~~}
\def\exec{\mathit{exec}}
\def\Act{\mathit{A\!ct}}
\def\Traces{\mathit{Traces}}
\def\Spec{\mathit{Spec}}
\def\uns{\mathit{unless}}
\def\ens{\mathit{ensures}}
\def\lto{\mathit{leads\!\!-\!\!to}}
\def\a{\alpha}
\def\b{\beta}
\def\c{\gamma}
\def\d{\delta}
\def\sP{\mbox{${\cal P}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sA{\mbox{${\cal A}$}}
\def\sB{\mbox{${\cal B}$}}
\def\sC{\mbox{${\cal C}$}}
\def\sI{\mbox{${\cal I}$}}
\def\sS{\mbox{${\cal S}$}}
\def\sD{\mbox{${\cal D}$}}
\def\sF{\mbox{${\cal F}$}}
\def\sG{\mbox{${\cal G}$}}
\def\sR{\mbox{${\cal R}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\ta{\mbox{$\widetilde{a}$}}
\def\tb{\mbox{$\widetilde{b}$}}
\def\tc{\mbox{$\widetilde{c}$}}
\def\tx{\mbox{$\widetilde{x}$}}
\def\ty{\mbox{$\widetilde{y}$}}
\def\tz{\mbox{$\widetilde{z}$}}
\def\tI{\mbox{$\widetilde{I}$}}
\def\norm{\mbox{$\parallel$}}
\def\sL{\mbox{${\cal L}$}}
\def\sM{\mbox{${\cal M}$}}
\def\sN{\mbox{${\cal N}$}}
\def\th{\mbox{$\widetilde{h}$}}
\def\tg{\mbox{$\widetilde{g}$}}
\def\tP{\mbox{$\widetilde{P}$}}
\def\norm{\mbox{$\parallel$}}
\def\to{\rightarrow}
\def\ov{\overline}
\def\gets{\leftarrow}
\def\too{\longrightarrow}
\def\To{\Rightarrow}
%\def\points{\mapsto}
%\def\yields{\mapsto^{*}}
\def\un{\underline}
\def\vep{$\varepsilon$}
\def\ep{$\epsilon$}
\def\tri{$\bigtriangleup$}
\def\Fi{$F^{\infty}$}
\def\Di{\Delta^{\infty}}
\def\ebox\Box
\def\emp{\emptyset}
\def\leadsto{\rightharpoondown^{*}}

\newcommand{\benum}{\begin{enumerate}}
\newcommand{\eenum}{\end{enumerate}}
\newcommand{\bdes}{\begin{description}}
\newcommand{\edes}{\end{description}}
\newcommand{\bt}{\begin{theorem}}
\newcommand{\et}{\end{theorem}}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
% \newcommand{\bp}{\begin{prop}}
% \newcommand{\ep}{\end{prop}}
\newcommand{\bd}{\begin{defn}}
\newcommand{\ed}{\end{defn}}
\newcommand{\brem}{\begin{remark}}
\newcommand{\erem}{\end{remark}}
\newcommand{\bxr}{\begin{exercise}}
\newcommand{\exr}{\end{exercise}}
\newcommand{\bxm}{\begin{example}}
\newcommand{\exm}{\end{example}}
\newcommand{\beqa}{\begin{eqnarray*}}
\newcommand{\eeqa}{\end{eqnarray*}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bcent}{\begin{center}}
\newcommand{\ecent}{\end{center}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\bcor}{\begin{corollary}}
\newcommand{\ecor}{\end{corollary}}
\newcommand{\bds}{\begin{defns}}
\newcommand{\eds}{\end{defns}}
\newcommand{\brems}{\begin{remarks}}
\newcommand{\erems}{\end{remarks}}
\newcommand{\bxrs}{\begin{exercises}}
\newcommand{\exrs}{\end{exercises}}
\newcommand{\bxms}{\begin{examples}}
\newcommand{\exms}{\end{examples}}
\newcommand{\bfig}{\begin{figure}}
\newcommand{\efig}{\end{figure}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\pair}[1]{\langle #1\rangle}
\newcommand{\tuple}[1]{\langle #1\rangle}
\newcommand{\size}[1]{| #1 |}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersection}{\cap}
\newcommand{\Intersection}{\bigcap}
\newcommand{\B}{\textbf{B}}
%\newcommand{\be}[2]{\begin{equation} \label{#1} \tag{#2} \end{equation}}
\newcommand{\abs}[1]{{\lvert}#1{\rvert}}
\newcommand{\id}[1]{\mathit{#1}}
\newcommand{\pfun}{\rightharpoonup}
%\newcommand{\ra}[1]{\kern-1.5ex\xrightarrow{\ \ #1\ \ }\phantom{}\kern-1.5ex}
%\newcommand{\ras}[1]{\kern-1.5ex\xrightarrow{\ \ \smash{#1}\ \ }\phantom{}\kern-1.5ex}
\newcommand{\da}[1]{\bigg\downarrow\raise.5ex\rlap{\scriptstyle#1}}
\newcommand{\ua}[1]{\bigg\uparrow\raise.5ex\rlap{\scriptstyle#1}}
% \newcommand{\lift}[1]{#1_{\bot}}
\newcommand{\signal}[1]{\tilde{#1}}
\newcommand{\ida}{\stackrel{{\sf def}}{=}}
\newcommand{\eqn}{\doteq}
\newcommand{\deduce}[1]{\sststile{#1}{}}

%% These don't sit very well with MathJax
%% so we don't plan to use theorem like environments
%% in org documents.
%% instead we plan to use headings with
%%  1. property drawers with a CLASS property identifying
%%  the environment
%%  2. A tag with the same name as the CLASS property
%%  In LaTeX export, these turn into (sub)sections.


%% See http://u.cs.biu.ac.il/~tsaban/Pdf/LaTeXCommonErrs.pdf
%% \newtheorem{prop}[thm]{Proposition}
%% \theoremstyle{plain}%default
%% \newtheorem{theorem}{Theorem}[section]
%% \newtheorem{lemma}{Lemma}[section]
%% \newtheorem{corollary}{Corollary}[section]
%% \newtheorem{definition}{Definition}[section]
%% \newtheorem{remark}{Remark}[section]
%% \newtheorem{example}{Example}[section]
%% \newtheorem{exercise}{Exercise}[section]



\newcommand{\less}[1]{#1_{<}}
\newcommand{\pfn}{\rightharpoonup}
\newcommand{\ffn}{\stackrel{{\sf fin}}{\rightharpoonup}}
\newcommand{\stkout}[1]{\ifmmode\text{\sout{\ensuremath{#1}}}\else\sout{#1}\fi}

% Caution: Not supported by MathJax!
% ----------------------------------
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}


% \usepackage{amsfonts} %% <- also included by amssymb
% \DeclareMathSymbol{\shortminus}{\mathbin}{AMSa}{"39}
\usepackage{mathpazo} %% <- because the OP uses mathpazo, optional



\newcommand{\mbf}[1]{\mathbf{#1}}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\rel}{\twoheadrightarrow}
\newcommand{\map}{\rightarrow}

%\newcommand{\fixed}{\boldsymbol{\circlearrowleft}}
\newcommand{\terminal}{\not\xto{}{}}
\newcommand{\fixed}{\bm\circlearrowleft}

\newcommand{\imp}{\rightarrow}
\newcommand{\dimp}{\leftrightarrow}  % double implication
\newcommand{\lequiv}{\Longleftrightarrow} % logical equivalence
\newcommand{\limplies}{\Rightarrow}
\newcommand{\lxor}{\veebar}
\)</div>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Short introduction to Racket: Syntax and a simple Evaluation Model</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc8b50be">1. A brief history of Racket</a></li>
<li><a href="#orgd23f990">2. Learning Racket's syntax</a></li>
<li><a href="#org4b9fedb">3. Datum</a>
<ul>
<li><a href="#orgd06386f">3.1. Atom</a></li>
<li><a href="#org06b9518">3.2. Vector</a></li>
<li><a href="#org09ca226">3.3. List Expression</a></li>
<li><a href="#orgd8c1ef0">3.4. Pair</a></li>
<li><a href="#org1353380">3.5. Nested Pairs</a></li>
<li><a href="#org7ea6a98">3.6. Conversion</a></li>
<li><a href="#org65c6d87">3.7. Lists</a></li>
<li><a href="#org8096289">3.8. Normal forms</a></li>
<li><a href="#orgf8b1331">3.9. Questions for future</a></li>
<li><a href="#orga61ea09">3.10. Uses of normal forms</a></li>
</ul>
</li>
<li><a href="#org5cb660b">4. Program syntax</a></li>
<li><a href="#orge8b7b4a">5. Derived Forms</a>
<ul>
<li><a href="#org82eecb3">5.1. Lexical (non-recursive) definitions</a></li>
<li><a href="#org8ab07e9">5.2. Sequencing</a>
<ul>
<li><a href="#orgc51ca9a">5.2.1. Syntax and meaning</a></li>
</ul>
</li>
<li><a href="#org1eff5a6">5.3. Conditional</a>
<ul>
<li><a href="#org05b2d72">5.3.1. Syntax</a></li>
<li><a href="#orgd0141b8">5.3.2. Transformation to <code>&lt;if&gt;</code> expressions</a></li>
</ul>
</li>
<li><a href="#org950c04c">5.4. Function definition</a>
<ul>
<li><a href="#orga57ff75">5.4.1. Transformation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1b5880f">6. Basic Evaluation mechanism of Racket</a>
<ul>
<li><a href="#org37db83b">6.1. Value</a></li>
<li><a href="#orgd6be2f6">6.2. Evaluation rules</a></li>
<li><a href="#org0837863">6.3. Keywords control evaluation, application forces evaluation</a></li>
<li><a href="#orgf65537f">6.4. Initial environment</a></li>
</ul>
</li>
<li><a href="#orgddf58f0">7. Quotation</a>
<ul>
<li><a href="#org7df3a88">7.1. Syntax</a></li>
<li><a href="#org3d4fd0a">7.2. Semantics</a></li>
</ul>
</li>
<li><a href="#org23b8411">8. Style</a>
<ul>
<li><a href="#orgc19bf84">8.1. Racket Style guide</a></li>
<li><a href="#org661a73f">8.2. Conventions for comments</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgc8b50be" class="outline-2">
<h2 id="orgc8b50be"><span class="section-number-2">1.</span> A brief history of Racket</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://racket-lang.org/">Racket</a> is a descendant of <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>.  When it comes to syntax,
Racket and Scheme are members of the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> family of languages,
which includes Common Lisp and also <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/">Emacs Lisp</a>.  The salient
feature of the syntax is that it uses white space and
parentheses.  Read these collection of mostly laudatory <a href="http://www.paulgraham.com/quotes.html">quotes
about Lisp</a>.)
</p>


<p>
Lisp was invented to study recursive function theory (McCarthy,
1958).  It was successfully and extensively employed in building
early Artificial Intelligence systems.  Scheme (Sussman and
Steele, 1975), a dialect of Lisp, grew out of an attempt to
understand Actors (Hewitt, 1972) in Lisp.  The result was a
language that, while sticking to Lisp's parentheses laden
syntax, was a significant departure from Lisp in its semantics:
it embraced lexical scope pioneered by Algol.  Lexical scope was
crucial to correctly modelling the Lambda Calculus (Church,
1932).  Scheme made it possible to write executable interpreters
for the Lambda Calculus (Sussman and Steele, 1975) and also many
features of programming languages.  (See the <a href="https://en.wikisource.org/wiki/Lambda_Papers">Lambda Papers</a>.)
(For an account of the History of Lambda Calculus, see
(<a href="https://pdfs.semanticscholar.org/959d/32cfa6df9299312ba51e2102045e1f25bc18.pdf">Cardone and Hindley, 2006</a>).
</p>

<p>
<a href="https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language">Scheme's evolution</a> proceeded via a series of Revised Reports,
the latest of which is <a href="https://github.com/johnwcowan/r7rs-spec/blob/errata/spec/r7rs.pdf">Revised<sup>7</sup> Report on the Algorithmic
Language Scheme</a>.  Scheme was designed to be small.  The
introductory paragraph of the Scheme Report captures this
philosophy:
</p>

<blockquote>
<p>
Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make additional
features appear necessary.  Scheme demonstrates that a very small number
of rules for forming expressions, with no restrictions on how they are
composed, suffice to form a practical and efficient programming language
that is flexible enough to support most of the major programming
paradigms in use today.
</p>
</blockquote>

<p>
Racket's immediate parent was PLT Scheme (Felleisen et al.)
which was another dialect of Scheme with its own interactive
development environment or IDE.  Racket evolved as Scheme
adding more data types, more keywords and many more built in
libraries to Scheme.  The presumptive goal was to make it
suitable for more real-world applications (`batteries
included'), with a module system, class system, many other
libraries, immutable lists, etc.
</p>
</div>
</div>

<div id="outline-container-orgd23f990" class="outline-2">
<h2 id="orgd23f990"><span class="section-number-2">2.</span> Learning Racket's syntax</h2>
<div class="outline-text-2" id="text-2">
<p>
If you're in a hurry, here is the <a href="https://docs.racket-lang.org/racket-cheat/index.html#%28part._top%29">Racket Syntax Cheat Sheet</a>.
The best way to learn the syntax of a programming language is to
start <i>small</i>, with a minimal set of constructs to get things
done.  To learn Racket, we will start with a very small subset
that drawn from the <a href="https://www.scheme.com/tspl2d/grammar.html">Syntax of Scheme</a>.  Racket's syntax includes
that of Scheme, but has other elements to it.
</p>

<p>
In the grammar below, for non-terminals whose definitions are
not listed here, please consult the
<a href="https://www.scheme.com/tspl2d/grammar.html">Scheme Syntax
Reference</a> or Racket Reference.
</p>

<p>
Racket's syntax is quite permissive.  Identifiers can all many
special characters, including spaces.  The language is
insensitive to the amount of white space, Any amount may be used
to separate syntactic elements.  Unlike Python, indentation is
not enforced, rather it is encouraged as good programming
practice.
</p>
</div>
</div>

<div id="outline-container-org4b9fedb" class="outline-2">
<h2 id="org4b9fedb"><span class="section-number-2">3.</span> Datum</h2>
<div class="outline-text-2" id="text-3">
<p>
The key to the syntax of Racket is the notion of a <i>datum</i>.
A datum is either list expression or a non-list expression.
In the latter case, it is either an atom or a vector of
datum elements.  In what follows, syntactic categories are
denoted by identifiers wrapped in <code>&lt;</code> and <code>&gt;</code>.
</p>

<pre class="example" id="org0b273f9">
&lt;datum&gt;         ::=  &lt;list-expr&gt; | &lt;non-list-expr&gt;
&lt;non-list-expr&gt; ::=  &lt;atom&gt; | &lt;vector&gt;
</pre>
</div>

<div id="outline-container-orgd06386f" class="outline-3">
<h3 id="orgd06386f"><span class="section-number-3">3.1.</span> Atom</h3>
<div class="outline-text-3" id="text-3-1">
<pre class="example" id="org0c3ea19">
&lt;atom&gt; ::=    &lt;boolean&gt;
            | &lt;number&gt;
            | &lt;character&gt;
            | &lt;string&gt;
            | &lt;symbol&gt;
            | &lt;procedure&gt;
</pre>
<p>
The syntax of atomic data is described in the Racket Guide
under <a href="https://docs.racket-lang.org/guide/datatypes.html?q=Racket%20Guide">Built-in Datatypes</a>.
</p>
</div>
</div>


<div id="outline-container-org06b9518" class="outline-3">
<h3 id="org06b9518"><span class="section-number-3">3.2.</span> Vector</h3>
<div class="outline-text-3" id="text-3-2">
<pre class="example" id="org68cebd0">
&lt;vector&gt; ::= #(&lt;datum&gt; ...)
</pre>

<p>
The meta notation <code>&lt;thing&gt; ...</code> denotes a sequence of zero
or more (but finite) occurrences of the category <code>&lt;thing&gt;</code>.
Note that the syntax of a vector consists of a hash <code>#</code>
followed by a pair of round brackets enclosing a sequence of
zero or more <code>&lt;datum&gt;</code> items.
</p>

<p>
Some examples of vectors:
</p>
<div class="org-src-container">
<pre class="src src-racket">#(3 4 5)
#("one" "two")
#()
</pre>
</div>
</div>
</div>


<div id="outline-container-org09ca226" class="outline-3">
<h3 id="org09ca226"><span class="section-number-3">3.3.</span> List Expression</h3>
<div class="outline-text-3" id="text-3-3">
<pre class="example" id="orgac772c7">
&lt;list-expr&gt;     ::=  (&lt;datum&gt; ...) | (&lt;datum&gt; &lt;datum&gt; ... . &lt;datum&gt;)
                                                          ^
                                                    note the dot 
</pre>

<p>
In the first variant, list expression is a sequence of zero
or more <code>&lt;datum&gt;</code> elements enclosed in round brackets.
(Square brackets are also permissible.)  Notice the absence
of commas between the elements.  As a special case list can
be empty, i.e., <code>()</code>.  
</p>

<p>
In the second variant, a list expression consists of a
sequence one or more <code>&lt;datum&gt;</code> elements followed by a dot
<code>.</code>, followed by another <code>&lt;datum&gt;</code>.  Notice that there can
be exactly one <code>&lt;datum&gt;</code> after the dot.
</p>
</div>
</div>

<div id="outline-container-orgd8c1ef0" class="outline-3">
<h3 id="orgd8c1ef0"><span class="section-number-3">3.4.</span> Pair</h3>
<div class="outline-text-3" id="text-3-4">
<p>
A <i>pair</i> is a list expression form <code>(&lt;datum&gt; . &lt;datum&gt;)</code>.
</p>

<pre class="example" id="org2915015">
&lt;pair&gt; ::=  (&lt;datum&gt; . &lt;datum&gt;)
</pre>
<p>
In a pair <code>(&lt;d1&gt; . &lt;d2&gt;)</code>, <code>&lt;d1&gt;</code> is called the <i>head</i> of
the pair, and <code>&lt;d2&gt;</code> the <i>tail</i> of the pair.  Note that a
pair may be represented as a labeled directed tree with
three nodes, the pair and <code>&lt;d1&gt;</code> and <code>&lt;d2&gt;</code> and edges
labeled `head' and `tail' from the pair to <code>&lt;d1&gt;</code> and <code>&lt;d2&gt;</code>
respectively.  
</p>

<p>
In the Lisp family parlance, a pair is also called a <i>cons
cell</i>, the two components of the pair are accessed via the
functions <i>car</i> and <i>cdr</i> operating on the pair.
</p>


<pre class="example" id="orgdafc2af">
(&lt;d1&gt; . &lt;d2&gt;)
  |    \
  |     \---tail---&gt; &lt;d2&gt;
  |
  +---head---&gt; &lt;d1&gt;
</pre>
</div>
</div>

<div id="outline-container-org1353380" class="outline-3">
<h3 id="org1353380"><span class="section-number-3">3.5.</span> Nested Pairs</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Pairs can be composed, or nested.  For example, consider the
nested pair <code>(3 . (a . (b . 5)))</code>.  The <i>gut</i> of the nested
pair is the right-most element in its tree representation.
In the example, the gut of the nested pair is <code>5</code>. 
</p>
</div>
</div>

<div id="outline-container-org7ea6a98" class="outline-3">
<h3 id="org7ea6a98"><span class="section-number-3">3.6.</span> Conversion</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Different list expressions may denote the same object.  For
example, the nested pair <code>(3 . (2 . ()))</code> is equivalent to <code>(3
2)</code>.  We seek a way to transform list expressions into other
list expressions.  The transformation process involves either
introducing or eliminating a `dot'.  Transforming to a nested
pair introduces a `dot'.  Transforming away from a nested pair
involves eliminiating a `dot'.  
</p>

<p>
The operation of elimination and introduction is captured by the
following ELIM/INTRO rewrite rules.  Transformation is the
process of applying these rewrite rules.
</p>

<pre class="example" id="orgb27ad36">
(&lt;d1&gt; &lt;d2&gt; ... . (&lt;d3&gt; . &lt;d4&gt;)) -&gt;  (&lt;d1&gt; &lt;d2&gt; ... &lt;d3&gt; . d4)    ; nest ELIM
(&lt;d1&gt; &lt;d2&gt; ... . ())            -&gt; (&lt;d1&gt; &lt;d2&gt; ...)               ; () ELIM


(&lt;d1&gt; &lt;d2&gt; ... &lt;d3&gt; . d4)  -&gt; (&lt;d1&gt; &lt;d2&gt; ... . (&lt;d3&gt; . &lt;d4&gt;))   ; nest INTRO
(&lt;d1&gt; &lt;d2&gt; ...)            -&gt; (&lt;d1&gt; &lt;d2&gt; ... . ())              ; () INTRO
</pre>


<p>
Each rule has a left hand side, a right hand side, and a name.
Here are some examples of transformations.  The rewrite rules
are specified with pattern variables (like <code>&lt;d1&gt;</code>, <code>&lt;d2&gt;</code>,
etc.).  
</p>

<pre class="example" id="orga9eda85">
(3 . (2 . (1 . ()))) =nest-ELIM=&gt; 
--------------------

(3 2 . (1 . ())) =nest-ELIM=&gt;
----------------

(3 2 1 . ()) =()-ELIM=&gt;
------------

(3 2 1)
</pre>

<p>
The underlines indicate a <i>redex</i>, short for <i>reducible
expression</i>.  A redex for a rule is a subexpression that
matches the left hand side of the rule.  It indicates the
subexpression to which the rewrite rule is being applied.
Note that in the above example transformation, the redex is
always the entire expression.  We say a redex rule is
applied at the `top level' when the redex is the entire
expression.
</p>


<pre class="example" id="org3487bf1">
(3 . ((2 . ()) . 4)) =nest-ELIM=&gt;
--------------------

(3 (2 . ()) . 4)    =()-ELIM=&gt;
   --------

(3 (2) . 4)
</pre>
<p>
Note that in the above example, the <code>()-ELIM</code> rule is not
applied  at top level.  
</p>
</div>
</div>
<div id="outline-container-org65c6d87" class="outline-3">
<h3 id="org65c6d87"><span class="section-number-3">3.7.</span> Lists</h3>
<div class="outline-text-3" id="text-3-7">
<p>
A <i>list</i> (or <i>list form</i>) is a list expression satisfying
the following grammar.  A list 
</p>

<pre class="example" id="orged534f0">
&lt;list&gt; ::= (&lt;datum&gt; ...) | (&lt;datum&gt; &lt;datum&gt; ... . &lt;non-list-expr&gt;)
</pre>

<p>
A list is <i>proper</i> if it is of the form <code>(&lt;datum&gt; ...)</code>.  It
is <i>improper</i> if it is of the form <code>(&lt;datum&gt; &lt;datum&gt;
... . &lt;non-list-expr&gt;)</code>.  (Note: in racket, the <code>list?</code> is
used for cheking for proper lists, not all lists.)
</p>

<p>
Another way of describing a list is that it is a list
expression that is not a redex for any of the ELIM rules.
In other words, in a list, the ELIM rules can not be applied
at the top level.
</p>

<p>
Every list expression may be converted to a list form by
repeatedly applying the elimination rules at the `top
level'.
</p>
</div>
</div>

<div id="outline-container-org8096289" class="outline-3">
<h3 id="org8096289"><span class="section-number-3">3.8.</span> Normal forms</h3>
<div class="outline-text-3" id="text-3-8">
<p>
A list expression is in <i>list normal form</i> if there are no
ELIM redexes in it.    Notice that a list expression may be
a list but not a list normal form.   For example, the list
expression <code>((3 . ()) 2)</code> is a list but is not in list normal
form.  However, it may be transformed to <code>((3) 2)</code>, which is
in list normal form. 
</p>

<pre class="example" id="org4eca6b3">
((3 . ()) 2)     ; in list form
                 ; but not in list normal form

((3) 2)          ; the result of transforming to list normal form
</pre>

<p>
A list expression is in <i>pair normal form</i> if there are no
redexes for any INTRO rewrite rule.   
</p>


<p>
Every list expression may be converted to a <i>pair
normal form</i> by applying the INTRO rules repeatedly until
saturation (i.e., until they are no longer any INTRO
redexes).  For example, the list expression <code>((3 . ()) 2)</code>
when converted to pair normal form is <code>((3 . ()) . (2
. ()))</code>.
</p>
</div>
</div>

<div id="outline-container-orgf8b1331" class="outline-3">
<h3 id="orgf8b1331"><span class="section-number-3">3.9.</span> Questions for future</h3>
<div class="outline-text-3" id="text-3-9">
<p>
We have claimed that every list expression may be
transformed into a list, into a list normal form, and a pair
normal form.  We haven't, however, proved this property.  At
least, not yet. 
</p>

<p>
 Also, what can we say about the uniqueness of the list and
pair normal forms?  Can a give list expression be
transformed to two distinct pair normal forms, or two
distinct list normal forms?  The answer, no: each list
expression transforms to, or has, exactly one pair normal
form and one list normal form.  Again, the proof of why this
is so is for later.
</p>
</div>
</div>

<div id="outline-container-orga61ea09" class="outline-3">
<h3 id="orga61ea09"><span class="section-number-3">3.10.</span> Uses of normal forms</h3>
<div class="outline-text-3" id="text-3-10">
<p>
All list expressions printed by Racket are in list normal
form and are prefixed with a quote (<code>'</code>) mark.  (We will
explain the role this quote mark shortly. ) It is convenient
to assume that internally, Racket stores list expressions in
pair normal form.   
</p>

<p>
All datum types discussed so far may be read by the Racket
interpreter, except a procedure.  It can not be read in, nor
its internals printed out.  It can, however, be part of a
list expression.
</p>
</div>
</div>
</div>

<div id="outline-container-org5cb660b" class="outline-2">
<h2 id="org5cb660b"><span class="section-number-2">4.</span> Program syntax</h2>
<div class="outline-text-2" id="text-4">
<p>
In what follows, we will stick to a very small subset of
Racket.  For the constructs whose definitions are not listed
here or for the full syntax, please consult the Racket
Reference Manual.
</p>

<pre class="example" id="org4368c62">
&lt;pgm&gt; ::= #lang racket &lt;form&gt; ...
&lt;form&gt; ::= &lt;defn&gt; | &lt;exp&gt; | &lt;require&gt; | &lt;provide&gt;

&lt;require&gt; ::= See Racket Reference
&lt;provide&gt; ::= See Racket Reference

&lt;defn&gt; ::= (define &lt;id&gt; &lt;exp&gt;)
&lt;exp&gt; ::= &lt;literal&gt;
          &lt;id&gt;                                    ; &lt;identifier&gt;
          (if &lt;exp&gt; &lt;exp&gt; &lt;exp&gt;) |                ; 
          (lambda &lt;formals&gt; &lt;exp&gt;) |              ; lambda expression
          (letrec (&lt;bind&gt; ...) &lt;exp&gt;)             ; recursive binding
          (&lt;exp&gt; &lt;exp&gt; ...)  |                    ; application
          (&lt;quote &lt;exp&gt;)                          ; quote

&lt;literal&gt; ::=  &lt;number&gt;                                ; number
             | &lt;boolean&gt;                               ; boolean
             | &lt;character&gt;                             ; char
             | &lt;string&gt;                                ; string    

&lt;id&gt; ::=   &lt;symbol&gt;
&lt;bind&gt; ::= (&lt;id&gt; &lt;exp&gt;) 
&lt;formals&gt; ::= (&lt;id&gt; ...) | (&lt;id&gt; ... . &lt;id&gt;) | &lt;id&gt;
</pre>
</div>
</div>
<div id="outline-container-orge8b7b4a" class="outline-2">
<h2 id="orge8b7b4a"><span class="section-number-2">5.</span> Derived Forms</h2>
<div class="outline-text-2" id="text-5">
<p>
So far, we have introduced only five keywords!  Racket has many
other keywords, but many of them are <i>derived</i>: they are defined
in terms of the basic form.  It is best to consider their
definitions via <i>pattern matching</i>:
</p>
</div>

<div id="outline-container-org82eecb3" class="outline-3">
<h3 id="org82eecb3"><span class="section-number-3">5.1.</span> Lexical (non-recursive) definitions</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<code>let</code> is derived syntax built as an application of a lambda
expression to arguments.
</p>

<pre class="example" id="orgf160457">
(let ([&lt;id&gt; &lt;e&gt;] ...) &lt;body&gt;) =&gt; ((lambda (&lt;id&gt; ...) &lt;body&gt;) &lt;e&gt; ...)
</pre>

<p>
Here <code>&lt;body&gt;</code> is any expression.  Note again the use of
<code>...</code> to denote zero or more of the previous syntactic
datum.
</p>
</div>
</div>

<div id="outline-container-org8ab07e9" class="outline-3">
<h3 id="org8ab07e9"><span class="section-number-3">5.2.</span> Sequencing</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<code>begin</code> is a way of evaluating a sequence of expressions and
returning the last one.
</p>
</div>

<div id="outline-container-orgc51ca9a" class="outline-4">
<h4 id="orgc51ca9a"><span class="section-number-4">5.2.1.</span> Syntax and meaning</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
The syntax of a begin expression is 
</p>

<pre class="example" id="org8285867">
(begin &lt;exp1&gt; &lt;exp2&gt; ...)
</pre>

<p>
The expressions <code>&lt;exp1&gt; &lt;exp2&gt; ...</code> are evaluated in sequence
and the value of the last expression is returned.
</p>

<pre class="example" id="org427fc71">
(begin e) =&gt; e
(begin e1 e2 ...) =&gt; (let ([x e1]) (begin e2 ...))
</pre>
<p>
Here <code>x</code> is assumed to be a `fresh' identifier name not
occur anywhere in the <code>begin</code> expression. 
</p>
</div>
</div>
</div>

<div id="outline-container-org1eff5a6" class="outline-3">
<h3 id="org1eff5a6"><span class="section-number-3">5.3.</span> Conditional</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Conditional expressions (starting with the <code>cond</code> keyword)
are derived using <code>if</code>.  Note the recursive nature of the
transformation.
</p>
</div>

<div id="outline-container-org05b2d72" class="outline-4">
<h4 id="org05b2d72"><span class="section-number-4">5.3.1.</span> Syntax</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
The (slightly simplified) syntax for conditional is
</p>

<pre class="example" id="org4d5b959">
&lt;cond&gt; ::= (cond &lt;clause&gt; ... [else &lt;exp&gt;])
&lt;clause&gt; ::= [&lt;exp&gt; &lt;exp&gt; ...]  
</pre>

<p>
Note that the a <code>&lt;cond&gt;</code> consists of zero or more clauses
followed by an `else' clause.   
</p>

<p>
Each <code>&lt;clause&gt;</code> has at least two expressions.  The first
expression in the clause is evaluated If it is true, the
remaining expressions in that clauses and the value of the last
one is returned.  Otherwise, the next clause is considered.  If
all the clauses `fail', then the expression in the else part is
evaluated as the value of the entire <code>else</code> expression.
</p>
</div>
</div>


<div id="outline-container-orgd0141b8" class="outline-4">
<h4 id="orgd0141b8"><span class="section-number-4">5.3.2.</span> Transformation to <code>&lt;if&gt;</code> expressions</h4>
<div class="outline-text-4" id="text-5-3-2">
<pre class="example" id="orgd61cf0f">
(cond [else e]) =&gt; e
(cond [e e1 e2 ...] clause ...)  =&gt; 
(if e 
   (begin e1 e2 ...)
   (cond clause ...))
</pre>
</div>
</div>
</div>


<div id="outline-container-org950c04c" class="outline-3">
<h3 id="org950c04c"><span class="section-number-3">5.4.</span> Function definition</h3>
<div class="outline-text-3" id="text-5-4">
<p>
When using Racket, you might  have used <code>define</code> in
for defining functions.   In that syntax, one often combines the
formal parameters of the function along with the identifier for
the function.  For example, consider the definition
</p>
<pre class="example" id="org20223ad">
(define (f x) 
   (+ x 2))
</pre>

<p>
In the first line, we know we are defining a function <code>f</code>
because of the formal parameters following <code>f</code>, as in <code>(f x)</code>.
</p>


<p>
The same may be written in the canonical way:
</p>
<pre class="example" id="orgc32ce57">
(define f 
   (lambda (x) (+ x 2)))
</pre>
</div>

<div id="outline-container-orga57ff75" class="outline-4">
<h4 id="orga57ff75"><span class="section-number-4">5.4.1.</span> Transformation</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
The transformation is simple.  The identifer <code>f</code> is now bound to
a <code>lambda</code> expression and the formals move next to  the <code>lambda</code>.  
</p>

<pre class="example" id="org63951a0">
(define (f formal ...) exp) =&gt; (define f (lambda (formal ...) exp))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1b5880f" class="outline-2">
<h2 id="org1b5880f"><span class="section-number-2">6.</span> Basic Evaluation mechanism of Racket</h2>
<div class="outline-text-2" id="text-6">
<p>
We describe a rather high level view of how Racket evaluates
expression.  This notion will be made much more precise
later in the course.  At this point, our goal is to build an
intuition of what Racket programs mean.
</p>
</div>

<div id="outline-container-org37db83b" class="outline-3">
<h3 id="org37db83b"><span class="section-number-3">6.1.</span> Value</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Racket expressions evaluate to <i>values</i>.  A value is a
datum.  Evaluation means taking an expression and returning
a value or raising an error.
</p>
</div>
</div>

<div id="outline-container-orgd6be2f6" class="outline-3">
<h3 id="orgd6be2f6"><span class="section-number-3">6.2.</span> Evaluation rules</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Each keyword is associated with an evaluation rule.
</p>

<ol class="org-ol">
<li><code>(define x &lt;exp&gt;)</code>: evaluate <code>&lt;exp&gt;</code> and bind the
result to <code>x</code>.  Return nothing.</li>

<li><code>&lt;literal&gt;</code>: return the value of the literal.</li>

<li><code>(lambda (x ...) &lt;exp&gt;)</code> :: create and return a
procedure whose formals are <code>(x ...)</code> and body is
<code>&lt;exp&gt;</code>.  The internal structure of a procedure is
unavailable.</li>

<li><code>(if &lt;test-exp&gt; &lt;then-exp&gt; &lt;else-exp&gt;)</code> :: Evaluated
<code>&lt;test-exp&gt;</code>.  If the result is not <code>#f</code>, then
evaluated <code>&lt;then-exp&gt;</code> and return the result of that
evaluation.  Else, evaluated <code>&lt;else-exp&gt;</code> and return
that as the value of the entire expression.</li>

<li><code>(&lt;rator-exp&gt; &lt;operand-exp&gt; ...)</code> Evaluate
<code>&lt;rator-exp&gt;</code>.  If it is not a procedure, then raise an
error.  Otherwise, evaluate each of the <code>&lt;operand-exp&gt;</code>
to create a list of values.  Pass these values as
arguments to the procedure resulting from evaluating
<code>&lt;rator-exp&gt;</code>.  If the number of arguments do not match,
raise an error.  Otherwise, bind the formals of the
procedure to the corresponding arguments, and under
these bindings, evaluate the body of the procedure.</li>

<li><code>&lt;id&gt;</code> :  Return the value to which the <code>&lt;id&gt;</code> is
bound.</li>

<li><code>(quote &lt;exp&gt;)</code> : Return <code>&lt;exp&gt;</code>.</li>
</ol>
</div>
</div>

<div id="outline-container-org0837863" class="outline-3">
<h3 id="org0837863"><span class="section-number-3">6.3.</span> Keywords control evaluation, application forces evaluation</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Notice that 
</p>

<ol class="org-ol">
<li>Keywords occur in the head position of a list, and</li>

<li>Keyword control the evaluation of the subsequent
elements of the list.</li>
</ol>

<p>
whereas in an application expression consisting of a
function expression and zero or more operand expressions,
</p>

<ol class="org-ol">
<li>the function expression is evaluated, and</li>

<li>all operand expressions are evaluated.</li>
</ol>
</div>
</div>

<div id="outline-container-orgf65537f" class="outline-3">
<h3 id="orgf65537f"><span class="section-number-3">6.4.</span> Initial environment</h3>
<div class="outline-text-3" id="text-6-4">
<p>
The `initial environment' or library comes with many
identifier bindings like <code>cons</code>, <code>car</code>, <code>list</code>, <code>null?</code>,
arithmetic identifiers like <code>+</code>, <code>*</code>, etc.  Note, none of
these are keywords, they are identifies bound to built-in
values (mostly functions).   
</p>
</div>
</div>
</div>

<div id="outline-container-orgddf58f0" class="outline-2">
<h2 id="orgddf58f0"><span class="section-number-2">7.</span> Quotation</h2>
<div class="outline-text-2" id="text-7">
<p>
Typing the following
</p>
<div class="org-src-container">
<pre class="src src-racket">#lang racket
a  
</pre>
</div>

<p>
Racket tries to evaluate the symbol <code>a</code>.  According to the
evaluator rules described above, evaluating an identifer
means looking at the value to which it is bound.  Here <code>a</code>
is not bound to anything, so Racket raises the error
</p>
<pre class="example" id="org7f6f07e">
a: unbound identifier
</pre>

<p>
On the other hand, the <code>quote</code> keyword prevents the
evaluation of 
</p>
<div class="org-src-container">
<pre class="src src-racket">#lang racket
(quote a)
</pre>
</div>

<p>
<code>(quote a)</code> is abbreviated <code>'a</code>.   Note that there is only a
single quote, there is no closing quote.  
</p>

<p>
<code>quote</code> has three other cousins <code>quasiquote</code>, <code>unquote</code> and
<code>unquote-splicing</code>.  They turn out to be extremely handy in
controlling the evaluation of expressions within a list
expression.  You may read about them in the Racket Manual.
</p>
</div>

<div id="outline-container-org7df3a88" class="outline-3">
<h3 id="org7df3a88"><span class="section-number-3">7.1.</span> Syntax</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The <code>quote</code> keyword and its three other cousins are
described next:
</p>

<pre class="example" id="orga3a0b25">
&lt;exp&gt; ::=  
         | &lt;quoted-form&gt;

&lt;quoted-form&gt; :=   (quote &lt;datum&gt;)  |
                   (quasiquote &lt;datum&gt;) | 
                   (unquote &lt;datum&gt;)    | 
                   (unquote-splice &lt;datum&gt;) | 
</pre>

<p>
The quoted forms may be abbreviated as follows:
</p>
<pre class="example" id="org44ef4bf">
`&lt;datum&gt;       -&gt;   (quote &lt;datum&gt;)  
`&lt;datum&gt;       -&gt;   (quasiquote &lt;datum&gt;) 
,&lt;datum&gt;       -&gt;   (unquote &lt;datum&gt;) 	  
,@&lt;datum&gt;      -&gt;   (unquote-splicing &lt;datum&gt;)
</pre>
</div>
</div>


<div id="outline-container-org3d4fd0a" class="outline-3">
<h3 id="org3d4fd0a"><span class="section-number-3">7.2.</span> Semantics</h3>
<div class="outline-text-3" id="text-7-2">
<p>
In the following we have used Haskell style notation <code>f x</code> to
denote <code>f(x)</code> or Racket's <code>(f x)</code> notation to reduce parentheses
clutter. 
Evaluating  a quoted datum returns datum
</p>
<div class="org-src-container">
<pre class="src src-txt">(eval (quote datum)) = datum
</pre>
</div>

<p>
Evaluating an unquote or unquote-splicing raises an error
</p>
<div class="org-src-container">
<pre class="src src-txt">eval (unquote &lt;datum&gt;) = error
eval (unquote-splicing &lt;datum&gt;) = error
</pre>
</div>

<p>
Evaluating a quasiquote of an atom returns the atom.
</p>

<div class="org-src-container">
<pre class="src src-txt">eval (quasiquote atom) = atom
</pre>
</div>

<p>
Evaluating a quasiquote of a unquote of an expression results in
the evaluation of the expression. 
</p>

<div class="org-src-container">
<pre class="src src-txt">eval (quasiquote (unquote exp)) = eval exp
</pre>
</div>

<p>
Evaluating a quasiquote of a pair whose head is a
<code>(unquote-splicing &lt;exp&gt;)</code> and tail is =(&lt;tail&gt;)
</p>
<div class="org-src-container">
<pre class="src src-txt">eval (quasiquote (cons (unquote-splicing exp) tail)) = append (eval exp) (eval (quasiquote tail))
</pre>
</div>

<p>
Otherwise, evaluating a quasiquote enclosing a pair is the 
pair of the results of evaluating the quasiquote of each of the
two components.  
</p>
<div class="org-src-container">
<pre class="src src-txt">eval (quasiquote (cons exp tail)) = cons (eval (quasiquote exp)) (eval (quasiquote tail))
</pre>
</div>

<p>
Evaluating the quasiquote of a vector is the vector obtained by
evaluating the quasiquote of each component of the vector:
</p>
<div class="org-src-container">
<pre class="src src-txt">eval (quasiquote (vector e1 ...)) = vector (eval (quasiquote e1) ...)
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org23b8411" class="outline-2">
<h2 id="org23b8411"><span class="section-number-2">8.</span> Style</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgc19bf84" class="outline-3">
<h3 id="orgc19bf84"><span class="section-number-3">8.1.</span> Racket Style guide</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Although Racket is quite agnostic to white space and other
indentation, remember that programs are written to be read.
Following, standard style rules leaves your reader with fewer
surprises.
</p>

<p>
Here is <a href="https://docs.racket-lang.org/style/Textual_Matters.html">Racket's own style guide and conventions</a>.  
</p>
</div>
</div>

<div id="outline-container-org661a73f" class="outline-3">
<h3 id="org661a73f"><span class="section-number-3">8.2.</span> Conventions for comments</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Racket, Scheme, and Emacs Lisp all share Lisp's syntax.  The
convention for commenting Lisp like programs is given here,
in the <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html">Tips on writing comments</a> in the Emacs-Lisp manual.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Venkatesh Choppella</p>
<p class="date">Created: 2024-08-16 Fri 00:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
